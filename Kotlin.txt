			 Kotlin , Spring boot with WebFlux
.....................................................................................

1.Kotlin
2.Project Reactor
3.Spring Boot Integration with Kotlin
4.Spring Boot with non blocking using WebFlux

What is Kotlin?
    Kotlin is the programming language for JVM.

JVM is runtime to run java applications.

JVM is abstract computer which solves the problem of platform independant.

One source and one Compiled code can be ported  on multiple platforms(os/hardware)

What is java?
  You mean java is programming language but not.
Java is technology, technolgy means solves the pratical problems.

Java technology means many things

1.Java programming language
2.tools
   compilers,debuggers,libs,apis....
3.runtime - jre
    -JDK


Java Programming language offers the source code , compiler compiles the source code into object code(byte code).

How java technology works? who controls java technology?

JCP - java community process who standarize the java technology.

All java versions and enchancments certified by JCP only...

JCP classifies java into there major editions

1.JAVA SE
2.JAVA EE
3.JAVA ME

JEP - This is committe formed by oracle
.....................................................................................
			JSR 223 :Scripting for The Java TM Platform
....................................................................................
JSR 223 spec was released on June-10-2003

Before this specification, only one programming language was there for JVM- Java Programming language.

The spec aim is to introduce new languages for JVM - Poly glot languages for Java Platform.

Based on this spec, the first language other than java pl, was created  for JVM-Groovy Programming langugage.

.....................................................................................
			    JSR 223 Poly glot language implementation


        java pl    Groovy   Scala  Kotlin Clojure XX
         -------------------------------------------
			 |
		      byte code
                         |
                        jvm



The programs are developed using different styles.

Programming styles:

1.Object oriented
2.Functional programming
3.Procedural
4.Rule based 
etc....

Any language follows any of one of the style or multi style(style).
C is procedural language-single style language.
c++ is object oriented language-single style language

java was object oriented programming - single style

Java is object oriented,functional style programming languge- multi style.

Kotlin is object oriented, functional style programming language...

Language is classified based on types(data types)
.................................................

1.strongly typed /static typed
   The type of variable is decided during compile time.
   int a=10;
   a="hello"
2.weak typed/dynamic typed
  The type of variable is decided during runtime time.
  var a =10
  a ="hello"

Kotlin is dynamic and strongly typed language.
...................................................................................

Programming language
 =>GPL - General Purpose programming language
     language used to build any type of apps
 =>DSL -  Domain specific language
     language used to build sepcific types of apps- html,css

kotlin helps to build dsl code...

DSL code is more declarative 
 
  move left and move right - dsl code
  find sqrt of 10 - dsl code
  take 1 pile every day at morning 7 am  

....................................................................................

Programming methodlogy

1.imperative programming
    => any program there is two aspects
        ->infra code
        ->application logic
    what is it? and how is it?

2.declarative programming
   focus only application logic
   more readable
   less boilerplate 
   less code maintaince because less code
  eg:
    list.sort.filter.map.find.flaten

Kotlin is more declarative programming  language.
.....................................................................................
	 "Kotlin helps to build more declarative, dsl , functional,object oriented          apps"


Kotlin language is highly multi purpose programming language:

 - To build mobile apps -> multi platform mobile - android and ios apps.
 - To build server side apps - microservices,RESTFull apis,dynamic web apps..
 - To build platform native apps like c++...


Learning Path:
1.language fundamentals
2.object oriented programming
3.functional programming
4.Exception handling
5.Data structures
6.Concurrency - Co-routines
7.Async programming / Non Blocking apps
8.How to build DSL

Frameworks:
1.web frameworks
2.android
3.Front End 

....................................................................................
				Language fundamentals
.....................................................................................

We are going to build console based Kotlin apps.

software req:
1.JDK
2.Intellij idea -  IDE 

Step to create Kotlin project.

You can use any build system to create kotlin project
Maven or Gradle.

Every Kotlin program is saved With "FileName.kt".

Unlike java kotlin programs need not be started with classes, you can start with main method(function).

Kotlin Programming style:

1.file based/script based
2.class based - oo style

How to declare functions in kotlin?

 fun functionName(arg){
   //function body...
 }
Every kotlin program begins with "main" function...
	
in java : System.out.println()

In Kotlin ; is optional

HelloWorld.kt

fun main(){
    println("Hello Kotlin")
}

Steps:
1.project creation.
2.write helloworld


HelloWorld.kt

package com.wipro.kotlin.basics

fun main() {
    println("Hello Kotlin")
}
....................................................................................

Language Fundamentals:

1.Comments
  Single line comment
	//
  Mutli line comment
	/**
        /**
/**
 * Every Kotlin program starts with main function.
 * In Kotlin ; optional
 */
fun main(){
    //which prints Hello message
    println("Hello Kotlin")
}
....................................................................................
			    Data types 
.....................................................................................

Program means collection of instructions.

instrcutions -(information + how the information is stored,processed,reterived)
information is nothing but data.

How to store data inside computer using programs?

we need to store in memory address, in order to store we need handle

variable: it is handle to store data.

Data:
 -simple data - atomic data - primtive data
  eg:10 -
any data can be broken into smaller unit.

Numbers:
   1.whole number
       -binary,oct,hexa
   2.decimal numbers
      - float


Abstract data types:
   In the begining of programming only basic were used by languages like numbers,characters.
   How to create our own type system- Type of data - Custom Types...

struct,union - c implemnetation of abstract types

Any abstract types are built on the top of built in types.
 
 struct Employee = {numbers,characters}

After some time new type creation syntax introduced "class"

 class Employee {
    numbers
    characters
 }
...................................................................................

Type - Data type
 -primtives
 -Complex type/Custom Type/Reference Type

Variable
 -Holder to hold any type 
Literal
 -Values(Primitives,Complex values)


In kotlin types are dervied from java language.

Java Primtive Types:
1.numbers
 -byte,short,int,long
 -float,double
2.char
3.boolean

In Kotlin you cant use primtives type directly... rather you have to use always "Complex type" - Reference Type - Wrappers Types.

In Kotlin , every thing is Object.

variables are introduced using keywords

-var
-val

variable declaration:
 
 var | val | withoutanyKeyword variableName:Type = literal

package com.wipro.kotlin.basics.types

fun main() {
    //var or val
    //int b=10; you cant declare like java
    var a: Int = 1
    var s: Short = 12
    var b: Byte = 10
    var l: Long = 19999
    var f: Float = 10.3f
    var d: Double = 90.334
    var isActive: Boolean = true
    println("Int " + a)
    println("Short " + s)
    println("Byte " + b)
    println("Long " + l)
    println("Float " + f)
    println("Double " + d)
    println("Boolean " + isActive)
}

Type inference:
 The type of variable is calculated based on the literal size.

var speed =100
 here the type of speed is calculated according to value
 by default Int type is assigned.

package com.wipro.kotlin.basics.types

fun main() {
    //var or val
    //int b=10; you cant declare like java
    var a = 1
    var s = 12 //as Short
    var b = 10 //as Byte
    var l = 19999 //as Long
    var f = 10.3f
    var d = 90.334
    var isActive = true
    println("Int " + a)
    println("Short " + s.toShort())
    println("Byte " + b.toByte())
    println("Long " + l.toLong())
    println("Float " + f.toFloat())
    println("Double " + d)
    println("Boolean " + isActive)


}
.....................................................................................
			 Static Typed language or Dynamic typed Language

Static type:
int a =10;
a=90; // it is valid
a=true //it is invalid - compile time error

Dynamic typed
in Js
 let a =10;
 a =100 //valid
 a=true //valid
In groovy
 def a =10
  a=10 //valid
  a=true //valid


Kotlin language is "strongly typed/Static typed" language, even though language looks like without type, but the type is infered
fun main(){
    var a =10
    println("A " + a )
    a=90
    println("A " + a )
    //a=true // invalid
    println("A " + a )

}
.....................................................................................
Strings :
 String is collection of unicode characters
 String Object 
 Strings are declared  with "" , """

Strings are concated with  + -> traditonal style

Strings are represented with "String Templates" - String interploation.

 "$variable" / "${}"

package com.wipro.kotlin.basics.types

fun main() {
    var firstName: String = "Subrmanaian"
    var lastName = "Murugan"
    //java style:it is not recommended
    println("Name" + firstName + lastName)
    //kotlin style: using string interpolation
    println("Name $firstName $lastName")

}

..................................................................................
				Multi Line Strings
...................................................................................

java style
package com.wipro.kotlin.basics.types


fun main() {
    //traditonal style: java style
    var doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body>" +
            "</body>" +
            "</html>"
    println(doc)
    //kotlin style
    var message = "Hello!!1"
    var newDoc = """
        <html>
         <head>
         <title>Home</title>
         </head>
         <body>
         <h1>${message}</h1>
         </body>
        </body>
    """.trimIndent()
    println(newDoc)
}
...................................................................................
			 var vs val
...................................................................................
package com.wipro.kotlin.basics.types

fun main() {
    var i = 10
    println("i $i")
    i = 90
    println("i $i")

    val j = 10
    println("j $j")
    //j=2323 //error 
    println("j $j")

}

var with variable can be reinitalized, where as val cant be reinitalized.
.....................................*****************.............................
...................................................................................
				Operators
....................................................................................

All operators supported by java  , supported by kotlin as well.

Types of operators
1.arithmetic operators
2.conditional operators
3.logical operators

package com.wipro.kotlin.basics.operators

fun main() {
    var a = 10;
    var b = 22;
    var c = a + b
    println("Add $c")
    c = a - b
    println("Substraction $c")
    c = a * b
    println("Multiplication $c")
    c = a / b
    println("Division $c")
    c = a % b
    println("Moduls $c")
    //augmentd operators
    var counter = 0
    counter += 1
    println("counter $counter")

    //logical operators : based on boolean expressions
    var isValid = true
    var isEnabled = false
    var res = isValid && isEnabled
    println("Result $res")

    //Equals : Structural equals
    var x = 100
    var y = 100
    var isEqual = x == y
    println("X AND  Y ARE Equal $isEqual")
    var str = "hello"
    var str1 = str
    println("str AND  str1 ARE Equal ${str1 == str}")
    
    //comparasional operators
    var isBig  = a > b
    println("IsBIg $isBig")

}
			.....................................................................................
			 conditional work flow
.....................................................................................
conditions: - if

In kotlin, "if" is an expression like (a+b,return 100),In java if is statement
it can return a value like functions.
so in kotlin there is no need for tenary operator.
(condtion ? truthy:falsy)- similar construct if expression provides
package com.wipro.kotlin.basics.ifexpression

fun main() {
    var a = 100
    var b = 2088
    var max = a
    //traditional style: java style
    if (a < b) {
        max = b
    }
    println("Max $max ")
    //Kotlin expression style
    if (a < b) max = b //here we return max variable
    println("Max $max ")

    //if..else ; java style
    if (a > b) {
        max = a
    } else {
        max = b
    }
    println("Max $max ")
    //if..else ; kotlin style

    max = if (a > b) a else b
    println("Max $max ")

    var isValid = true
    var res = if (isValid) "Greet" else "Good Bye"
    println(res)
    //block of code with if and else
    res = if (isValid) {
        println("More code")
        var firstName = "Subramnaian"
        //return value
        "Hello $firstName"
    } else {
        println("More code")
        var firstName = "Murugan"
        //return value
        "How are you? Mr/Mrs $firstName"
    }
    println(res)


}
....................................................................................
When expression:
...............
 When is similar to if expression, but when defines a condtions with multiple branches. which is similar to switch statement...
In Kotlin no switch case...

Simple When:
package com.wipro.kotlin.basics.conditionalexpression

fun main() {
    //simple when
    var x = 1
    when (x) {
        1 -> println("x is 1")
        2 -> println("x is 2")
        else -> println("No Match Found")
    }
}
either this or that
package com.wipro.kotlin.basics.conditionalexpression


fun main() {
    //simple when
    var x = 10
    when (x) {
        0, 10 -> println("X value is 0 or 10")
        else -> println("No match found")
    }
}
Range:
package com.wipro.kotlin.basics.conditionalexpression

fun main() {
    var input = 120
    when (input) {
        in 1..107 -> println("Input is part of this range  1- 100")
        !in 1..100 -> println("Input does not part of this range")
    }
}

//return result from when expression:
package com.wipro.kotlin.basics.conditionalexpression

fun main() {
    var isLoggedIn = false
    var status = when (isLoggedIn) {
        true -> "LoggedIn"
        false -> "LoggedOut"
    }
    println(status)
}

if when expression arg is not supplied, the branch conditions are simply boolean expression, and a branch is executed when its condition is true.

package com.wipro.kotlin.basics.conditionalexpression


fun main() {
    var num = 3;
    var isEvenOrOdd = when {
        num % 2 == 0 -> "Even"
        num % 2 != 0 -> "Odd"
        else -> "No Match Found"
    }
    println(isEvenOrOdd)
}
.....................................................................................
....................................................................................
				Loops
...................................................................................
Loops:
 for
 range
 while
 do...while

package com.wipro.kotlin.basics.loops

fun main() {
    //RANGE
    for(count in 1..10){
        println("Count $count")
    }
    //reverse order
    for(count in 5 downTo 1){
        println("Count $count")
    }
    //step by
    for (count in 1..10 step 2){
        println("Count $count")
    }
    //until
    for (count in 5 until 10 ) println("Count Until $count")
}
.....................................................................................
				Functions
.....................................................................................

What is function?
  The term function is derived from the mathmetics.
  The function represents unit of execution
  The function is building block of computer system itself.

Types of functions?
1.passive functions
2.active functions

Every program is running on another program called runtime/Process

aJava programs are running on the another program called JVM.
J
VM is written in c language.

JVM is just process just like other process running on operating system.

Every Process has its own arch...

Process has three seg.

1.heap
2.Stack 
3.Program data

Program data/method area
........................
  All passive instructions are stored.
  Passive instructions means that instructions are not used by CPU and Main memory.

All functions declrations are stored inside this area
All Static variables are stored inside this area
All literals(values) are stored inside this area
....................................................................................
			 Runtime Represention of functions
...................................................................................

In Programs, runtime representation means, which should be accessed by CPU,Memory should be allocated inside main memory.

Every functions must be allocated on RAM, so that it can be accessed by CPU.

//declaration

function main(){ 

}

main()---> we have to allocate memory on RAM--->

When function is called, the function is pushed into stack.

Stack is just first in last out data structure.

Once the function gets pushed into stack, The process allocates memory.

This memory is called as "Stack Frame"

After execution of statck frame it is removed from memory, so that other stack frames will start 

sayHello----frame is created---frame is running---frame is removed
sayHai -----framew is created ---frame is runnin-frame is removed
....................................................................................
.....................................................................................
			  Kotlin functions
....................................................................................

Kotlin supports different functions

1.normal functions
2.infix function
3.local function
4.member function
5.Tail Recursive function
6.inline function
7.suspend function
8.operator function
9.lambda functions

1.normal function
 -how to declare function
 -how to invoke 
 -args and parameters
   -Named,optional args
 -return types  and values
package com.wipro.kotlin.functions.normal

//other functions

//fun declaration
fun sayHello() {
    //function body
    println("Hello");
}

//fun with some logic
fun add() {
    var a = 10
    var b = 20
    var c = a + b
    println("Add Result $c")

}

//Every Kotlin has entry point called main function
fun main() {
    //invoke function
    sayHello();
    add();
}
....................................................................................
			 Function args and parameters
...................................................................................

What is arg?
 Arg is place holder which holds values
What is parameter?
 Parameter is nothing but value what we pass.


package com.wipro.kotlin.functions.normal.args

fun sayHello(message: String) {
    println(message)
}
fun add(a:Int,b:Int){
    var c = a + b
    println("C $c")
}

fun main() {
    sayHello("Hello")
    add(10,10)
}
............
Default Args:
  In java parameters must be passed for given args,
  In Kotlin you can skip parameters, we can provide default args

package com.wipro.kotlin.functions.normal.args.defaultargs

fun add(a: Int = 0, b: Int = 0) {
    var c = a + b
    println("a $a b $b c $c")
}

fun main() {
    add()
    add(10,20)
}
...................................................................................
			Positional and Named Parameters
....................................................................................

In java parameters are position based

void add(int a,int b){

}
add(10,10)
void format(String str,boolean b,int a){

}
format("sss",true,10)

Kotlin also supports positions based.

eg
fun add(a: Int = 0, b: Int = 0) {
    var c = a + b
    println("a $a b $b c $c")
}

fun main() {
    add()
    add(10,20)
}
...................................................................................
			 Named Parameters
...................................................................................
You can pass values in any order.
Named args also can have default values.
You can skip values any where in the arg list.

package com.wipro.kotlin.functions.normal.args.defaultargs

fun format(str: String = "str", normalizeCast: Boolean = false, upperCaseFirstLetter: Char = 'A') {
    println("Str $str noralizeCase ${normalizeCast} UpperCaseFirstLetter ${upperCaseFirstLetter}")
}

fun main() {
    format();
    //named parameters
    format(str = "Hello", upperCaseFirstLetter = 'B', normalizeCast = true)
    format(normalizeCast = false);
}


Positional and Named Parameters

1.function does not have default values -  Optional parameter
2.function with default value- Named parameter
.....................................................................................

Any type:

package com.wipro.kotlin.functions.normal.args.defaultargs

//Any is like  java.lang.Object in java.
//In Kotlin every thing Object, Super Object is "Any"
fun accept(a: Any) {
    println(a)
}

fun main() {
    accept("hello")
    accept(100)
    accept(true)
    accept(33.44)
}
....................................................................................
			 Return values and Type
....................................................................................

In Kotlin function returns any object if function does return any thing which is Called "Unit".

The "Unit" is type with only One Value- Unit

package com.wipro.kotlin.functions.normal.returntypes

//Explicit Unit
fun doStuff(): Unit {
    println("unit")
    return
}

fun doSomething() {
    println("unit")
    return
}

fun main() {
    doStuff()
    doSomething()
}

Other types:
package com.wipro.kotlin.functions.normal.returntypes

//Explicit Unit
fun doStuff(): Unit {
    println("unit")
    return
}

fun doSomething() {
    println("unit")
    return
}

//String
fun sayHello(): String {
    return "Hello"
}

fun add(a: Int = 0, b: Int = 0): Int {
    return a + b
}

fun main() {
    doStuff()
    doSomething()
    println(sayHello())
    println(add(a = 10, b = 90))
}
....................................................................................
			 Single-Expression functions
....................................................................................
When a function returns a "single Expression" no more body, the curly braces and return statement can be omitted and body can be specified after = symbol
return type can be ommitted, which is typeinferenced 

package com.wipro.kotlin.functions.normal.returntypes

//fun sum(a: Int = 0, b: Int = 0): Int {
//    return a * b
//}
//Single expression function
//fun sum(a: Int = 0, b: Int = 0): Int = a * b
//return type also can be ommitted
fun sum(a: Int = 0, b: Int = 0) = a * b
fun accept(name: String = "name") = "Hello $name"

fun main() {
    println(sum(123, 45)) //position
    println(sum(b = 90, a = 10)) //Named parameter
    println(accept("Subramanian"))
}
....................................................................................
			 Variable args-Var args
...................................................................................

In order to receive variable args, kotlin provides a keyword "vararg".

package com.wipro.kotlin.functions.normal.args.varargs

fun logger(vararg args: String) {
    for (arg in args) println(arg)
}

fun main() {
    logger("Employee.kt", "Warning", "Save Method is called")
    logger("Employee.kt", "Error", "remove Method is called", "501")
}
.....................................................................................
			null
.....................................................................................

What is null?
  
int a =10; 
String str =null



10 is value
null ? value ----> it is value

Different languages implement null differently.
In java null is Object. NULL object.

NULL Object means , you dont have valid Object of that Type.

if you access any property on Null Object , It will throw error- NullPointerException.


if NullPointer Exception occurs, the system crashes.

Handling null in java like language is really challanging....
...................................................................................
			How to handle  Null in Kotlin
...................................................................................
Null reference/Object is unavoidable in any object oriented systems, handling null is more chaallange.

How to handle null very safely?

  Kotlin like languages now a days handles null very efficiently without crashing system.
  Kotlin handles null positiviely, if there is null, we can give alternate values.

In java , the methods,properties access are verfied during run time only.
String str =null
str.trim() 

In java , null is verified during runtime.
................

In Kotlin "null" is verified during compile itself, so that your code will be more strong and safe during development and production

App never crashes because of null errors.
....................................................................................
			 Kotlin and null
.....................................................................................

1.Kotlin never allows null by default.

package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name:String = null 
}
The code causes compile time error
 "Null can not be a value of a non-null type String"
  
package com.wipro.kotlin.basics.nulldemo

fun main() {
    //var name:String = null
    var name: String
    println(name)
}
The code also causes compile error.
 because when declaration of variable , no error, but when access the variable ,it will give you error.

As of now the variable must have been initialized to some string.

What if i want null to be initalized to a variable. How to declare null in kotlin?

What if i want "nullable" value?

"nullable" means the variable can have null.

var variableName:Type? = null

package com.wipro.kotlin.basics.nulldemo

fun main() {
    //var name:String = null
    var name: String? = null
    println(name)
}
....................................................................................
			What if i access any property on null
....................................................................................
package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name:String? = null 
    println(name.length)
}
this code causes compile time error, you cant access any property on null reference.


Way 1: Handling null using java style

package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name: String? = null
    //Ways to handle null
    //Way 1: Handling null using java style
    if (name != null) {
        println(name.length)
    }
}

Way 2: Kotlin style "Using safe navigation operator

variable?.property
  here if variable has null , then output would be "null" string representation.

package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name: String? = null
    //Ways to handle null
    //Way 1: Handling null using java style
    if (name != null) {
        println(name.length)
    }

    //Way 2: Kotlin style "Using safe navigation operator
    println(name?.length)
}

Way 3: Kotlin style "Using Elvis Operator" : if there is null,if you want some default  instead of "null" string.

package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name: String? = null
       //Way 3: Kotlin style "Using Elvis Operator" : if there is null,if you want some default
    // instead of "null" string.
     var length = name?.length ?: 0
    println("String length is $length")
}

way 4: kotlin style: for some reasons,"if you want Runtime Exception" How to throw NullPointerException !! assertion operator which throws runtime exception.


package com.wipro.kotlin.basics.nulldemo

fun main() {
    var name: String? = null
    //way 4: kotlin style: for some reasons,"if you want Runtime Exception" How to        //throw NullPointerException
    //!! assertion operator which throws runtime exception.
    println("${name!!.length}")
}
.....................................................................................
			Functions and Nullable values
...................................................................................
package com.wipro.kotlin.basics.nulldemo

fun sayHello(name: String? = "") {
    println("Hello ${name} and its length is ${name?.length ?: 0}")
}

fun main() {
    sayHello(null)
    sayHello(name = "Murugan")
}
.....................................................................................
			  Functional Programming
.....................................................................................

What is functional Programming?
  Functional programming is one of the programming style to build apps...

Programming Principles:
1.Procedural programming - c
2.Object oriented programming - c++,java,C#....
3.functional programming.

Functional programming principles and patterns implemented from the mathmetics called  "Lambda calculus".

Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.
 It is a universal model of computation that can be used to simulate any Turing machine. 

"The word function derived from calculus"

According to calculus function means which accept as input, and return result.

calculus talks about how to build "Abstract Computer"

calculus was introduced by matmetician called "Alonzo Chruch in the 1930".

Based on calculs , the first programming language was created called "LISP"

Lisp, an acronym for list processing, is a functional programming language that was designed for easy manipulation of data strings. As one of the oldest programming languages still in use, Lisp offers several different dialects and has influenced the development of other languages.

Lambda Calculs implementation languages:
........................................
1.Lisp
2.CommonLisp
3.Clojure - Lisp for JVM
4.Haskell
5.Scheme
6.Javascript
7.JVM languages
   - java 8 on wards
   - Groovy
   - Scala
   - Kotlin 
   - Clojure

Functional Programming principles(calculus Basic):
..................................................

1.Functions are first class Citizens
2.Referetial transparency
3.Pure functions
   Side effects, immutablity
4.Recurrsive functions rather than loops.
....................................................................................
			 Purely functional and functional style
....................................................................................

Purely functional programming language means, the language implements 100% all fp principles
Functional style programming language means, partitial principles are implemented.

"Kotlin is functional style language".
.............

Kotlin functional programming implementations:
...............................................

1.Functions are first class Citizens

 What is first class citizen?
	
  Functions are passed around(in ,out)

This means the language supports passing function as parameter to another function,returing them as values from another function, and assigning them to variables or storing them in data structure.

"functions are literal , means that functions are value like int,double,String"

var a=10
 here a is variable
 here 10 is value(literal)

in kotlin functions are treated like 10

var myTask = fun delay(){}

Higher order functions:
.......................
	First class functions are necessity for the functional programming style, in which the use of higher order functions is standard practice.

According to calculus mathmetics, higher order function is a function that does the following things

1.Takes one or more function as arg
2.Returns a function as its result.

Can i say the below fun is higher order function or not?

fun map(){

}
No , Because it does not follow the thumb rule of hof.
.....................................................................................
			Since Kotlin Static Typed language, we need to tell the 
				"Type of function Itself"
....................................................................................

fun map(variableName:FunctionType){

}
In Kotlin, every thing is object, FunctionType itself is object behind the scene.
....................................................................................
			  Kotlin Function Type syntax
....................................................................................

Note: T means Type

1.(T)->T
 eg:
  (Int)->Int
  (Int)->String

2.(T1,T2)-T3
  (Int,Int)->Int
  (String,Int)->String

3.(T)->Unit
  (Int)->Unit
  ()->Unit

fun map((T)->T){

}

Rules:
 1.All function tyes must have a parenthesized types list and return type
 2.Function type can be optinally have an additional receiver type, which is represented in "." notation

  "ReceiverType".(B,C)->D
eg:
   A.(B,C)->D

A - Receiver Object
B,C -args
D-Return type

3.Incase of async code,

suspend A.(B,C)->D
suspend (B,C)->D

Nullable and function args:

((A,B)->C)?
(a.(B,C)->D)?
.....................................................................................

Function Literals:
...................

 As we dicussed already functions are literals/values, can be stored into a variable.

 Since function stored inside variable, that variable can be used to invoke that function.


package com.wipro.kotlin.functionalprogramming

var sayHello: () -> Unit = fun() {
    println("Hello")
}

fun main() {
  sayHello()
}
here sayHello is just variable only pointing function literal
()-> Unit => It is type of that function
 fun() {
    println("Hello")   => function reference(value)
}

Here no name of the function that is called "anonymous function"

...........

functions without type annotation: type inference:

package com.wipro.kotlin.functionalprogramming

//Function with type inference
var greet = fun() {
    println("Greet")
}

fun main() {
    greet()
}

Anonymous Function with Parameters:


package com.wipro.kotlin.functionalprogramming

//With type
//var add: (Int, Int) -> Int = fun(a: Int, b: Int): Int {
//    return a + b
//}
//without Type
//var add = fun(a: Int, b: Int):Int {
//    return a + b
//}
//Single function expression with anonymous function
var add = fun(a: Int, b: Int) = a + b

fun main() {
    println(add(10, 3));
}

Nullable parameters and Anonymous function:
.............................................
package com.wipro.kotlin.functionalprogramming

//var accept: (String?) -> String? = fun(message: String?): String? {
//    return message
//}
//var accept = fun(message: String?): String? {
//    return message
//}
var accept: ((String) -> String)? = fun(message: String): String {
    return "Hello $message"
}
var display = fun(message: String?): String? {
    return "Hello $message"
}

fun main() {
    //println(accept("Hello"));
    accept?.invoke("Hello")
    display?.invoke("Hello");
    display?.invoke(null)
}
....................................................................................
			 Higher order functions
/////////////////////////////////////////////////////////////////////////////////////

Function is passed as parameter to another function.

Before understanding higher order function, we need to understand, how parameters are passed.

package com.wipro.kotlin.functionalprogramming.hof

fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
    //How to pass values to the function?
    //hard coded value
    println(add(10, 10))
    //via variables
    var x = 10
    var y = 20
    println(add(x,y))
}

Simple Higher order function:
package com.wipro.kotlin.functionalprogramming.hof

//Basic higher order function
fun sayGreet(action: () -> Unit) {
    action.invoke()
    action()
}

//


fun main() {
    //passing functions pattern
    var hello = fun() {
        println("Hello")
    }
    //passing function via variable
    sayGreet(hello)
    //passing function as literal to the function
    sayGreet(fun() {
        println("Hello")
    })

}
....................................

Higher orders with args and paramters:
.....................................
package com.wipro.kotlin.functionalprogramming.hof

fun adder(action: (Int, Int) -> Unit) {
    action(10, 10)
}

fun main() {
    adder(fun(a: Int, b: Int) {
        var c = a + b
        println("C $c")
    })
}

Named Parameters with Higher order function:
............................................
package com.wipro.kotlin.functionalprogramming.hof

fun login(
    userName: String = "foo",
    password: String = "bar",
    resolve: (String) -> Unit,
    reject: (String) -> Unit
) {

    if (userName == "admin" && password == "admin")
        resolve("Login Success")
    else
        reject("Login failed")

}

fun main() {
    login(userName = "admin",
        password = "admin",
        fun(status) { println(status) },
        fun(err) {
            println(err)
        })
    login(userName = "foo",
        password = "bar",
        fun(status) { println(status) },
        fun(err) {
            println(err)
        })
}
....................................................................................
		    Lambdas
....................................................................................

What is Lambda?
 The term Lambda is derived from Lambda calculs.

Lambdas are function literals only, can be assigned to a variable, passed around(in and around).

How to declare Lambda expression?

var or val variableName:FunctionType = {arg->functionbody}

Rules:
1.A lambda expression is always surroned by {}
2. Parameter declarations in the full synatatic form go inside curly braces and have optional type annotations.
4.The body of the function will go after "->"
5.The infered return type is not "Unit" by default, the last line (possibly) expression inside the lambda body is treated as the return value.
6.Lambda can be passed to another function as parameter or Lambdas can be passed to another lambda as parameter.

package com.wipro.kotlin.functionalprogramming.lambdas

//normal function
fun add(a: Int = 1, b: Int = 1): Int {
    return a + b
}

//Single expression function
fun addExression(a: Int = 1, b: Int = 1) = a + b

//function as literal : default values can't be initialized in the function literal
var addFunLiteral = fun(a: Int, b: Int): Int {
    return a + b
}

//function  lambda
val addLambda = { a: Int, b: Int ->
    //body of the function
    //last line of the function to be treated as return value
    a + b
}

fun main() {
    println(add())
    println(addExression())
    println(addFunLiteral(33, 333))
    println(addLambda(1, 2))
}
.....................................................................................
			Lambda Complex syntax
.....................................................................................
package com.wipro.kotlin.functionalprogramming.lambdas

//var login: (String, String) -> String = { userName: String, password: String ->
//    if (userName == "admin" && password == "admin")
//        "Login Success"
//    else
//        "Login Failed"
//}
var login = { userName: String, password: String ->
    if (userName == "admin" && password == "admin")
        "Login Success"
    else
        "Login Failed"
}

fun main() {
    println(login("admin", "admin"))
}
..................................................................................
		Lambda with Single Paramter - it variable
...................................................................................
"it" is implicit variable can be used in lambda to replace single explicit args

package com.wipro.kotlin.functionalprogramming.lambdas

//var sayMyName = { name: String ->
//    name.uppercase()
//}
//using it variable
var sayMyName: (String) -> String = {
    println("test")
    println("demo")
    it.uppercase()
}

fun main() {
    println(sayMyName("Subramanian"))
}
...................................................................................
			Higher order functions and Lambda
...................................................................................
How to pass lambda as parameter to another function or another lambda?

package com.wipro.kotlin.functionalprogramming.lambdas

fun delay(action: () -> Unit) {
    action()
}

fun main() {
//passing regular function as parameter
    delay(fun() {
        println("delay")
    })
    //passing lambda
    var task = {
        println("task-lambda")
    }
    delay(task)
    delay({
        println("task-lambda")
    })
}
.....................................................................................
How lambda can accept another lambda as parameter?

package com.wipro.kotlin.functionalprogramming.lambdas

//Inside lambda, it variable is not available when function passed as parameter or function as type
//var async1:() -> Unit = {
//    it()
//}

var async = { action: () -> Unit ->
    action()
}


fun main() {

    var task = {
        println("task-lambda")
    }
    async(task)
    async({
        println("lambda task 1")
    })
    async(fun() {
        println("delay")
    })
}
...................................................................................
			DSL - Domain Specific language
...................................................................................

More readable code english like statement.
Kotlin supports building dsl programs

Basic DSL Syntax:

When we pass lambda as parameter to the function/another lambda we can ommit braces ()
package com.wipro.kotlin.functionalprogramming.dsl

fun delay(action: () -> Unit) {
    action()
}

fun repositories(action: () -> Unit) {
    action()
}

fun mavenCentral() {
    println("downloading jar dependencies")
}

fun main() {
    var task = {
        println("task-lambda")
    }
    // normal syntax
    delay(task)
    delay({
        println("Delay lambda ")
    })
    //dsl syntax
    delay(task) // when you pass variable, you can ommit braces
    delay {
        println("Delay lambda ")
    }
    repositories {
        mavenCentral()
    }
}
.....................................................................................
		 Higher order function takes more parameters(mixed)


package com.wipro.kotlin.functionalprogramming.dsl

fun compute(no: Int = 0, action: () -> Unit) {
    println("No $no")
    action()
}

fun main() {
    compute(10, { println("compute") })
}

DSL syntax for more parameters:
...............................
When you pass lambda as second or last parameter, the first parameter can be enclosed with "()" and second parameter passed passed directly.

Note: lambda should be always last parameter.

package com.wipro.kotlin.functionalprogramming.dsl

import kotlin.concurrent.thread

fun compute(no: Int = 0, action: () -> Unit) {
    println("No $no")
    action()
}

fun filterBy(
    order: String = "asc",
    name: String = "name",
    no: Int = 0,
    action: () -> Unit
) {
    println("Order $order Name $name No $no")
    action()
}

fun main() {
    compute(10, { println("compute") })
    //dsl syntax
    compute(23) { println("compute") }
    //dsl syntax with default value
    compute { println("compute") }

    filterBy { println("Filter callback") }
    filterBy(name = "Subramanian", order = "asy", no = 1) {
        println("Filter callback with values")
    }
    //Thread creation using lambda
    thread(start = true, name = "MyThread1", priority = 2) {
        Thread.sleep(2333)

        println("${Thread.currentThread().name}")
    }

    thread(start = true, name = "MyThread2", priority = 1) {
        println("${Thread.currentThread().name}")
    }

    thread(start = true, name = "MyThread3", priority = 2) {
        println("${Thread.currentThread().name}")
    }
}
....................................................................................
			_ notation in lambda
...................................................................................
package com.wipro.kotlin.functionalprogramming.dsl

fun doCompute(a: Int = 0, b: Int = 0, action: (Int, Int) -> Unit) {
    action(a, b)
}

fun main() {
    doCompute(b = 233) { _, b -> println(b) }
}
...................................................................................
		 How to pass lambda as parameter to another lambda
...................................................................................
package com.wipro.kotlin.functionalprogramming.dsl

package com.wipro.kotlin.functionalprogramming.dsl

var asyncTask = { action: (String) -> Unit ->
    action("async task")
}

var async = { payload: String, action: (String) -> Unit ->
    action(payload)
}

fun main() {
    asyncTask { println(it) }
    async("async payload") { println(it) }
}
.....................................................................................
			 Object oriented programming in kotlin
.....................................................................................

How to declare classes in kotlin and how to create object?
package com.wipro.kotlin.oo.classes

class Customer {
    //instance variables
    var id: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var status: Boolean? = null

}

fun main() {
    //customer is reference variable
    //val customer: Customer = Customer()
    val customer = Customer()
    //no need of adding getters and setters ; kotlin provides default getters and setters
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")

}
...................................................................................
			 State(data/properties) initalization
...................................................................................

1.inside class
2.outside class after object creation
3.during object creation- constructors

1.Inside class
package com.wipro.kotlin.oo.classes.stateinit


class Customer {
    //instance variables
    var id: Int? = 0
    var firstName: String? = "Subramanian"
    var lastName: String? = "Murugan"
    var status: Boolean? = true

}

fun main() {
    //customer is reference variable
    //val customer: Customer = Customer()
    val customer = Customer()
    //no need of adding getters and setters ; kotlin provides default getters and setters
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")

}

2.Outside class

package com.wipro.kotlin.oo.classes.stateinit


class Customer {
    //instance variables
    var id: Int? = 0
    var firstName: String? = "Subramanian"
    var lastName: String? = "Murugan"
    var status: Boolean? = true

}

fun main() {
    //customer is reference variable
    //val customer: Customer = Customer()
    val customer = Customer()
    customer.id = 1
    customer.firstName = "Geetha"
    customer.lastName = "Subramanian"
    customer.status = true
    println("Id ${customer.id}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("Status ${customer.status}")

}
....................................................................................
			 init block
...................................................................................

init is a special block used to initalize the variables and any code.

A Single class can have multiple init block but recommened having only one init block.

init blocks are getting executed the order in which it has been declared.
package com.wipro.kotlin.oo.classes.stateinit


class Employee {
    //instance variables
    var id: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var status: Boolean? = null

    init {
        id = 1
        firstName = "foo"
        lastName = "bar"
        status = false
    }
    init {
        println("init 2")
    }
}

fun main() {
    //customer is reference variable
    //val customer: Customer = Customer()
    val employee = Employee()

    println("Id ${employee.id}")
    println("Name ${employee.firstName} ${employee.lastName}")
    println("Status ${employee.status}")

}
.....................................................................................
			Setter and getters
.....................................................................................

According to java bean spec, java needs to have setters and getters

According to kotlin setters and getters are implicit.

Can we use getters and setters in kotlin?

Yes!

Syntax:
  var <PropertyName>:[PropertyType] = [<property_initalizer>]
  getter
  setter
package com.wipro.kotlin.oo.classes.settersgetters

class User {
    var name: String? = null
        set(value) {
            field = "Mr/Mrs $value"
        }
        get() = field?.uppercase()

}

fun main() {
    val user = User()
    user.name = "Subramanian"
    println(user.name)
}
.....................................................................................
		How to initalize the properties during object creation
.....................................................................................

Constructors are sepcial methods are used to initalize the object propreties during object creation.

Types of constructors:

1.Primary constructor as default constructors
2.Secondary constructor are used for overloading.


Primary constructors:
 Primary constructors are added as part of the class header

class ClassName constructor(){}

Note:
  if the primary constructor does not have any annotations or visibility modifer,the constructor keyword can be ommitted.

class ClassName(){}
class ClassName [private | @someAnnotation] constructor (){}

primary constructors does not have any code, if you want any special initalization, should be given inside "init" block.


package com.wipro.kotlin.oo.constructors

class Person constructor(var firstName: String = "", var lastName: String = "", var age: Int = 0) {

}

fun main() {
    var person = Person();
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 18)
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
}

with constructor keyword

class Person(var firstName: String = "", var lastName: String = "", var age: Int = 0) {

}

fun main() {
    var person = Person();
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 18)
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
}


without {} braces:
class Person(var firstName: String = "", var lastName: String = "", var age: Int = 0) 

fun main() {
    var person = Person();
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 18)
    println("Name ${person.firstName} ${person.lastName}")
    println("Age ${person.age}")
}
...............................................................................
			secondary constructors
...............................................................................

A class can have more than one constructors apart from the primary constructor, generally to mimic the over loading.

Secondary constructors are declared with class using constructor keyword.

Always we have to call primary constructor via "this()"

package com.wipro.kotlin.oo.constructors

package com.wipro.kotlin.oo.constructors

class MyClass constructor() {
    //secondary constructors
    constructor(a: String) : this() {
        println("Constructor with String arg")
    }

    constructor(a: Int) : this() {
        println("Constructor with Int arg")
    }

    constructor(a: Double) : this() {
        println("Constructor with Double arg")
    }
}

class Employee constructor(var name: String = "", var salary: Double = 0.0) {
    constructor(name: String) : this(name, 10.1) {
        println("Constructor with String arg")
    }
}

fun main() {
    MyClass("hello")
    MyClass(20)
    MyClass(34.44)
    var emp = Employee("Test", 22.333)
    println(emp.name)
    println(emp.salary)
}
.....................................................................................
			class Members
.....................................................................................

A class contain many things

1.constructors, and initalizers
2.properties
3.functions
4.Nested and inner classes
5.Object declarations 

Functions inside class:
package com.wipro.kotlin.oo.classes.functions

class TodoService {
    //functions
    fun findAll(): String {
        return "FindAll"
    }

    fun remove(id: Int) = "$id Removed"
    var update = {
        "updated"
    }
}

fun main() {
    var todoService = TodoService()
    println(todoService.findAll())
    println(todoService.update())
    println(todoService.remove(333))
}
.....................................................................................
				Dynamic Programming
....................................................................................

In java , if you declare methods inside class, only those methods will be available once if the code gets deployed in runtime.

Once clas becomes object, we can only use the methods defined already.

Can we add new Methods dynamically into Object dynamically.

Util.java
public class Util{
  public void transform(){

  }
}
Util util = new Util()
util.transform()

here apart from "transform" method we cant use other methods.

Some languages(js,groovy) offers a feature to add method dynamically during runtime without explicitly declaring inside class - "dynamic programming"

"Kotlin provides the ability to extend(add) a class or interface with new functionality without having to inherit or use any design patterns like "Decorators"

This is done via secial declarations called "Extensions"


Use case:
If you are using third party libs/frameworks that you cant modify, if you want to add any special apis, you can do that.

You can call that functions as if they were methods of the original class - "this is called extension function"

Not only you can add functions but also you can add properties - Extension properties.

Extension Function:

To declare extension function , the prefix its name with a "Receiver Type" , the on which this function attached.

syntax:

fun ReceiverType.method(args) {}

package com.wipro.kotlin.oo.classes.extensions

class Util {
    fun sayHello(): String {
        return "Hello"
    }
}

//extensions:
fun Util.sayHai(): String {
    return "Hai"
}

fun main() {
    var util = Util()
    println(util.sayHello())
    println(util.sayHai())
}
.....................................................................................
			Can we extend any built in classes

Yes, if you look at java, String is final class, meaning you cant extend the class, so you cant have your own String api.

Thats where extension function comes into picture.


package com.wipro.kotlin.oo.classes.extensions


class Util {
    fun sayHello(): String {
        return "Hello"
    }
}

//extensions:
fun Util.sayHai(): String {
    return "Hai"
}

//extensions with string
fun String.add(name: String): String {
    //kotlin provides this keyword to access receiver type
    return this + name
}

fun Int.myadd(no1: Int): Int {
    return this.plus(no1)
}

//Extension Properties
val Util.greetings: String
    get() = "Extension property"

val String.city: String
    get() = "Coimbatore"

fun main() {
    var util = Util()
    println(util.sayHello())
    println(util.sayHai())
    var str: String = "Hello";
    var name = "Subramanian"
    //str is receiver type
    println(str.add(name));
    var number = 100
    println(number.myadd(22))

    var n = 10
    println(n.plus(12))

    //Extension property access
    println("".city)
    println(util.greetings)
}
.....................................................................................
			   infix functions
.....................................................................................

What is infix function?

  functions are marked with infix keyword called "infix functions"
  Infix functions are used to create DSL based code, we can omit the parentheses

class Greeter {
    infix fun sayHello(name: String) {
        println("$this $name")
    }
}

val greet = Greeter()
greet.sayHello('eee')

greet saHello('ee')

greet saHello 'ee'

"hello" indexof 1

Rules:
1.It must be member function or extension function
2.They must have single parameter
3.The parameter must not accept var args and must have no default value.

package com.wipro.kotlin.oo.classes.infixnotation

class Greeter {
    infix fun sayHello(name: String) {
        println("$this $name")
    }
}
infix fun Greeter.sayHai(name:String) {
    println("$this $name")

}

fun main() {
    var greeter = Greeter()
    greeter.sayHello("Hello")
    greeter sayHello "Hello"
    greeter sayHai "hai"
}
....................................................................................
			  inline functions
....................................................................................

What is inline?
   By inserting the function code at the address of each function call, there by saving the overhead of a function.
	
		"copy and paste function into calling place"


Regular functions:

fun foo(){
  bar()
}
fun bar(){

}

foo()------stack frame is created------bar()-------stackframework is created

Source code

fun foo(){
  bar()
}
inline fun bar(){
  for(var i=0; i<1000){
     println("computing"
  }
}

compilter
fun foo(){
   for(var i=0; i<1000){
     println("computing"
  }
}
inline fun bar(){
  for(var i=0; i<1000){
     println("computing"
  }
}
Inlining basically requesting the compiler to copy the (inlined) code at the calling place.

Why?
  Avoiding un necessary stack frame creations so that you can avoid tracking return address,args,values...

Kotlin and inline functions:
............................

In Kotlin, the hof and lambdas are reprsented as objects behind the scene, same thing in java also.

Since it is object takes some memory and increases the memory overhead if function gets called more no of times.

In order to reduce memory overhead of such functions we can use the "inline" keyword

"inline" requests the CPU not to allocate any memory for the function and simply the copy body of that function at the calling place.

package com.wipro.kotlin.oo.classes.inlinefunc

inline fun filter(condition: Boolean): Boolean {
    return condition
}

fun main() {
    //call inline function
    for (count in 1..100) {
        println(filter(true))
    }
}
.....................................................................................
			 Object Relationship - Hierachy
.....................................................................................

There are two types of hiearchy
1.has-a - Dependency injection
2.IS-a - Inheritance.

Has-a:
.......
package com.wipro.kotlin.oo.hierarchy

class Item(var id: Int = 0, var itemName: String = "")
class Product(var id: Int = 0, var name: String = "", var item: Item? = null)

class OrderService {
    fun findAll(): String {
        return "orders"
    }
}

class OrderController(var orderService: OrderService? = null) {
    fun findAll(): String? {
        return orderService?.findAll()
    }
}

fun main() {
    var orderCtrl = OrderController(OrderService())
    println(orderCtrl.findAll())

    orderCtrl = OrderController()
    println(orderCtrl.findAll())

    var product = Product(item = Item())
    println("Product ID ${product.id}")
    println("Product Name ${product.name}")
    println("Item ID ${product.item?.id}")
    println("Item Name ${product.item?.itemName}")

    product = Product(
        item = Item(
            id = 100,
            itemName = "Phone"
        ), id = 1, name = "IPHONE"
    )
    println("Product ID ${product.id}")
    println("Product Name ${product.name}")
    println("Item ID ${product.item?.id}")
    println("Item Name ${product.item?.itemName}")

}
.....................................................................................
		    IS-A - Inheritance
....................................................................................

Implementation of inheritance:

1.concrete class
2.interfaces
3.abstract classes

Kotlin and inheritance:
.......................
By default any class cant be inherited,All classes are freezed by default except abstract classes
Inheritance is disabled by default
In Kotlin all classes are "final class" by default

class MyClass: BaseClass() {

}
package com.wipro.kotlin.oo.hierarchy

//base class 
class Animal {
    
}
//child class
class Dog : Animal {
    
}

fun main() {
    
}
Compile time error:
 This type is final, so it cannot be inherited from

What if i want to make inheritance?
 "just" use the keyword called "open" infront of class

package com.wipro.kotlin.oo.hierarchy

//base class
open class Animal {

}
//child class
class Dog : Animal() {

}

fun main() {

}

eg:
package com.wipro.kotlin.oo.hierarchy

//base class
open class Animal {
    init {
        println("Animal constructor is running")
    }
}

//child class
class Dog : Animal() {
    init {
        println("Dog constructor is running")
    }
}

fun main() {
    var dog = Dog()
}
....................................................................................
			   Typing
.....................................................................................

How the reference variable going to bind the expressions during compile and run time.

 //program to sub type
    var dog: Dog = Dog()
    //program to super type
    var mydog: Animal = Dog()

Polymorphism:
.............

The reference variable binds the properties and methods are verfied during compile time. whether that method belongs this method.

package com.wipro.kotlin.oo.hierarchy.typing

//base class
open class Animal {
    fun eat(){
        println("eat")
    }
}

//child class
class Dog : Animal() {

}

fun main() {
    //program to sub type
    var dog: Dog = Dog()
    dog.eat()
    //program to super type
    var mydog: Animal = Dog()
    mydog.eat()
}

Runtime:
 The runtime calls the implementation side,the object side (right side)
 Program to super type
 This is called runtime polymorphism.

How to implement eat method in Dog class?
  Overriding

 In kotlin methods inside class not overriable by default - by default methods are final.
 by no methods will be available for inheritance.

"open" keyword must be used.

in the child class we must be use 'override' keyword in order to override.

package com.wipro.kotlin.oo.hierarchy.typing

//base class
open class Animal {
    open fun eat() {
        println("animal eat")
    }
}

//child class
class Dog : Animal() {

    override fun eat() {
        println("dog eats")
    }
}

fun main() {
    //program to sub type
    var dog: Dog = Dog()
    dog.eat()
    //program to super type
    var mydog: Animal = Dog()
    mydog.eat()
}
.................................................................................
			Program to Super Type and Sub class Methods
..................................................................................
package com.wipro.kotlin.oo.hierarchy.typing

//base class
open class Animal {
    open fun eat() {
        println("animal eat")
    }
}

//child class
class Dog : Animal() {

    override fun eat() {
        println("dog eats")
    }

    fun bark() {
        println("dog is barking")
    }
}

fun main() {
    //program to sub type
    var dog: Dog = Dog()
    dog.eat()
    //program to super type
    var mydog: Animal = Dog()
    mydog.eat()
    mydog.bark()
}

here bark method does not available in the Animal type.

Rules:
 During compile time, the compiler looks left side(type), for method expression binding
 During runtime the run time looks right side(instance side)- dynamic method dispatch.

Having base class type, how to invoke dervied class method?

We have solution called type casting 
We have to cast animal type into dog type - down casting.

"as" operator can be used to convert animal type to dog type.

package com.wipro.kotlin.oo.hierarchy.typing

//base class
open class Animal {
    open fun eat() {
        println("animal eat")
    }
}

//child class
class Dog : Animal() {

    override fun eat() {
        println("dog eats")
    }

    fun bark() {
        println("dog is barking")
    }
}

fun main() {
    //program to sub type
    var dog: Dog = Dog()
    dog.eat()
    //program to super type
    var mydog: Animal = Dog()
    mydog.eat()
    //mydog.bark()
    var tmpDog = mydog as Dog
    tmpDog.bark()
}
....................................................................................
			 How to override properties
....................................................................................
package com.wipro.kotlin.oo.hierarchy.typing

open class Shape {
    open val x: Int = 0
}

class Square : Shape() {
    override val x: Int = 100
}

fun main() {
    val shape = Square()
    println(shape.x)
}
...................................................................................
		How to call super class methods and properties from child 
...................................................................................
package com.wipro.kotlin.oo.hierarchy.typing

open class Account {
    open fun deposit(): Int {
        return 100
    }
}

class SavingsAccount : Account() {
    override fun deposit(): Int {
        return super.deposit().plus(1000) 
    }
}

fun main() {
    var account:Account = SavingsAccount()
    println(account.deposit())
}
.....................................................................................
			Interfaces
....................................................................................
package com.wipro.kotlin.oo.hierarchy.interfaces

interface Eatable {
    //open fun eat(): String
    fun eat(): String
}

class Dog : Eatable {
    override fun eat(): String {
        return "Dog eats"
    }

    fun bark() {
        println("dog barks")
    }
}

fun main() {
    var dog: Eatable = Dog()
    println(dog.eat())
    //dog.bark()
    var tmpDog: Dog = dog as Dog
    tmpDog.bark()
}

..................................................................................

Multiple interfaces:
package com.wipro.kotlin.oo.hierarchy.interfaces

interface Eatable {
    //open fun eat(): String
    fun eat(): String
}
interface Runnable {
    fun run():String
}

class Dog : Eatable ,Runnable  {
    override fun eat(): String {
        return "Dog eats"
    }

    override fun run(): String {
        return "Dog run"
    }

    fun bark() {
        println("dog barks")
    }
}

fun main() {
    var dog: Eatable = Dog()
    println(dog.eat())
    //dog.bark()
    var tmpDog: Dog = dog as Dog
    tmpDog.bark()

    var newDog = Dog()
    println(newDog.bark())
    println(newDog.eat())
}
.....................................................................................
			Interfaces and implementations
....................................................................................
package com.wipro.kotlin.oo.hierarchy.interfaces

interface MyInterface {
    fun sayHello():String
    fun doStuff(){
        println("MyInterface")
    }
}
interface FooInterface {
    fun sayHai():String
    fun doStuff(){
        println("FooInterface")
    }
}
class Implementator: MyInterface,FooInterface {
    override fun sayHai(): String {
        TODO("Not yet implemented")
    }

    override fun sayHello(): String {
        TODO("Not yet implemented")
    }

    override fun doStuff() {
        super<FooInterface>.doStuff()
    }
}

fun main() {
    var bar = Implementator()
    bar.doStuff()
}
....................................................................................
				Abstract class
....................................................................................
package com.wipro.kotlin.oo.hierarchy.abstractclasses

open class LivingThings {
    open fun walk() {
        println("Animal walk")
    }
}

//valid
//open abstract class Animal : LivingThings() {
//    abstract fun eat()
//    fun saveAnimals() {
//        println("Save Animals")
//    }
//}
//valid
abstract class Animal : LivingThings() {
    abstract fun eat()
    fun saveAnimals() {
        println("Save Animals")
    }
}

class Dog : Animal() {
    override fun eat() {
        println("Dog eats")
    }

    override fun walk() {
        println("Dog walk")
    }
}


fun main() {
    val dog: Animal = Dog()
    dog.eat()
    dog.saveAnimals()
    dog.walk()
}
....................................................................................
				Functional Interaces-SAM
..................................................................................

Kotlin supports SAM

There are two styles to implement of SAM.

1.java style
  Using anonymous inner class
2.Kotlin style
  we have to declare function with fun keyword.

Inside interface all methods are abstract methods

if an interface having single abstract method without implementatons, that interface is called "SAM"

SAM is used inside lambda expressions.

java style interface:
package com.wipro.kotlin.oo.hierarchy.sam

//java style interface
interface Greeter {
    fun greet(): Unit  //single methods
}
class GreeterImpl:Greeter {
    override fun greet() {
        println("Greet")
    }
}

fun main() {
    val greeter = GreeterImpl()
    greeter.greet()

    //anonymous implementation.
    var mygreet = object : Greeter {
        override fun greet() {
            println("Anonmous implementation")
        }
    }
    mygreet.greet()
}

//
Kotlin Style:
package com.wipro.kotlin.oo.hierarchy.sam

//kotlin style
fun interface Hello {
    fun sayHello(): Unit
}

fun interface Predicate {
    fun accept(i: Int): Boolean
}

fun main() {
    var hello = object : Hello {
        override fun sayHello() {
            println("Hello")
        }
    }
    hello.sayHello()
    //Lambda notation
    var myHello = Hello {
        println("Hello")
    }
    var isEven = Predicate { it % 2 == 0 }
    println(isEven.accept(33))
}
...................................................................................
				Encapuslation
...................................................................................

How to share code and how to restrict code from one class into class or one package into package, one module into another module.

modifiers:
private,protected,internal and public.

public :
 It is default modifer

class Hello {}

..
package com.wipro.kotlin.oo.encapsulation

//public class
//public class Hello {
//
//}
class Hello {

}
//public function
//public fun sayHello(){
//
//}
fun sayHello() {
    println("hello")
}
//public var name = "Subramanian"

fun main() {
    sayHello()
}


package com.wipro.kotlin.oo.encapsulation.subpack

import com.wipro.kotlin.oo.encapsulation.Hello

fun main() {
    var hello = Hello()
}

private:
package com.wipro.kotlin.oo.encapsulation

private class User {

}

private fun update() {

}

private var password = "foo"

fun main() {
    var user = User()
}

package com.wipro.kotlin.oo.encapsulation.subpack

import com.wipro.kotlin.oo.encapsulation.Hello
//import com.wipro.kotlin.oo.encapsulation.User
fun main() {
    var hello = Hello()
//    var user = User ()
}

protected:
 visibile inside class and its subclasses
package com.wipro.kotlin.oo.encapsulation

open class Animal {
    protected open fun eat() {
        println("animal eat")
    }
}

package com.wipro.kotlin.oo.encapsulation.subpack

import com.wipro.kotlin.oo.encapsulation.Animal
import com.wipro.kotlin.oo.encapsulation.Hello

//import com.wipro.kotlin.oo.encapsulation.User

class Dog : Animal() {
    //public is explicitly needed ; by default protected methods are private
    public override fun eat() {
        println("Dog eats")
    }

}

fun main() {
    var hello = Hello()
//    var user = User ()
    var mydog = Dog()
    mydog.eat()
}
................

internal:
 In kotlin new modifier is added called internal, which is not supported in java.

internal means that it will be available in the module. if any is declared with in the module scope, will be avaible within that module only. if you try to access from another module which will not be available.

module: 
  group of files that compiled togther.

Module could be:
An intellij Module
A maven project
A Gradle source set
A set of files compiled with one invocation of the kotlinc Ant task

Use case : 
 we create multi module project...
 if you delclare class,function,variable,interface with "internal keyword".


package com.wipro.kotlin.oo.encapsulation

internal class MyLib {

}

internal fun getVersion(): String {
    return "Interal"
}
internal var copyRight = "google"

package com.wipro.kotlin.oo.encapsulation.subpack

import com.wipro.kotlin.oo.encapsulation.Animal
import com.wipro.kotlin.oo.encapsulation.Hello
import com.wipro.kotlin.oo.encapsulation.MyLib
import com.wipro.kotlin.oo.encapsulation.getVersion

//import com.wipro.kotlin.oo.encapsulation.User

class Dog : Animal() {
    //public is explicitly needed ; by default protected methods are private
    public override fun eat() {
        println("Dog eats")
    }

}

fun main() {
    var hello = Hello()
//    var user = User ()
    var mydog = Dog()
    mydog.eat()

    var mylib = MyLib()
    getVersion()
}
....................................................................................
			 Packages
...................................................................................

What is package?
  It is way to organize the code.

package nameofthePackage

//declarations
private | public | internal | class  | fun | variable

Types of packages:

1.custom packages
2.built in packages
3.third party packages

Built in packages:

package 

kotlin 
  it is core package which is eq to java.lang package.
Core functions and types, available on all supported platforms.

kotlin.collections-datastructure
kotlin.coroutines - async programming
kotlin.concurrent - threading
kotlin.io - for io operations

etc...
..........................................................................

Core Package: Kotlin.

Any:
  It is root of every Kotlin class . which is eq to java.lang.Object
  The root of the Kotlin class hierarchy. Every Kotlin class has Any as a superclass.

Core apis of Any

1.toString
2.hashCode
3.equals
4.scope functions..

toString:
 returns string representation of object, by default "Any" class has logic, but you can override and give your own implementation

package com.wipro.kotlin.oo.anyClass

class Sample {

}

fun main() {
    var sample = Sample()
    println(sample.toString())
}
output:
com.wipro.kotlin.oo.anyClass.Sample@6d311334

package com.wipro.kotlin.oo.anyClass

class Sample {
    override fun toString(): String {
        return "Sample"
    }
}

fun main() {
    var sample = Sample()
    println(sample.toString())
}

hashcode:
package com.wipro.kotlin.oo.anyClass

class Sample {
    override fun toString(): String {
        return "Sample"
    }

    override fun hashCode(): Int {
        return 334343
    }
}

fun main() {
    var sample = Sample()
    println(sample.toString())
    println(sample.hashCode())
}


equals
package com.wipro.kotlin.oo.anyClass

class Square(val side: Int) {
    override fun equals(other: Any?): Boolean {
        //is eq instanceof
        if (other is Square) {
            return other.side == side

        }
        return false
    }
}

fun main() {
    var square1 = Square(10)
    var square2 = Square(10)
    var isEqual = square1.equals(square2)
    println(isEqual)

    //== compares properties of object
    var isEqual1 = square1 == square2
    println(isEqual1)

    // using === operator compares the location of object
    var isEqual2 = square1 === square2
    println(isEqual2)

    var tmpSquare = square1
    println(tmpSquare === square1)

}

== and equals called "Structural Equality"  - Object property verification
=== is called "Reference Equal - Object address verification
....................................................................................
		What if i want all methods of Any class override in sub classes
.....................................................................................

"Data class"

 It is sole purpose is to hold data.

Data classes hold standard functionality and some utility functions such as toString,hashcode,equals.

package com.wipro.kotlin.oo.anyClass

data class User(val name: String, val age: Int)

fun main() {
    var user = User("Subramanian", 18)
    println(user.toString())
    println(user.hashCode())
    //clonning api
    val newUser = user.copy(age = 43)
    println(newUser)
}
....................................................................................
			 Object Destructuring
....................................................................................

Instead of reading object properties using "variable.proprty", you can read properties directly.

package com.wipro.kotlin.oo.anyClass

data class Person(var id: Int, var name: String, var city: String)

fun main() {
    var person = Person(id = 1, name = "Subramanian", city = "Coimbatore")
    println("Without Destructuring")
    println("id ${person.id} Name ${person.name} City ${person.city}")

    println("Destructuring")
    var (id, name, city) = person
    println("id ${id} Name ${name} City ${city}")

}
.....................................................................................
		   		Sealed Classes
...................................................................................

Sealed classes and interfaces represent restricted class hierachies that provide more control over inheritance.

All Direct subclasses of a sealed class are known at compile time.

No other subclasses may appear outside a module within which the sealed classed is defined.

Sealed classes are abstract by default, so it cant instantiated.

package com.wipro.kotlin.oo.sealedClasses

//Sealed classes
sealed class MyResult {
    data class Success(val resolve: String) : MyResult()
    data class Failure(val reject: String) : MyResult()
    class Loader() : MyResult()
}

// api which returns sealad class
fun getSuccess(): MyResult {
    return MyResult.Success("Data is available")
}

fun getFailure(): MyResult {
    return MyResult.Failure("Something is went wrong")
}

//all in one
fun fetch(): MyResult {
    var status = 200
    if (status === 200)
        return MyResult.Success("Response found")
    return MyResult.Failure("failed")
}


fun main() {
    var success = getSuccess()
    when (success) {
        is MyResult.Success -> {
            println(success.resolve)
        }
        is MyResult.Failure -> {
            println(success.reject)
        }
        else -> {
            println("Loading")
        }
    }
    var failure = getFailure()
    when (failure) {
        is MyResult.Success -> {
            println(failure.resolve)
        }
        is MyResult.Failure -> {
            println(failure.reject)
        }
        else -> {
            println("Loading")
        }
    }

    var response = fetch()
    when (response) {
        is MyResult.Success -> {
            println(response.resolve)
        }
        is MyResult.Failure -> {
            println(response.reject)
        }
        else -> {
            println("Loading")
        }
    }
}
....................................................................................
				Enum classes
...................................................................................

package com.wipro.kotlin.oo.enumclasses

enum class Color {
    RED, BLUE, GREEN, YELLOW
}

fun main() {
  println(Color.GREEN)
}
....................................................................................
			Enum Initalizers
.....................................................................................

package com.wipro.kotlin.oo.enumclasses

enum class Color {
    RED, BLUE, GREEN, YELLOW
}

enum class Day(val day: Int) {
    MONDAY(1),
    TUESDAY(2),
    WEDNESDAY(3),
    THURSDAY(4),
    FRIDAY(5),
    SATURDAY(6),
    SUNDAY(7)

}

fun main() {
    println(Color.GREEN)
    println(Day.MONDAY.day)
}
.....................................................................................
			 Nested classes and inner classes
....................................................................................
package com.wipro.kotlin.oo.innerclasses

class Counter {
    init {
        println("outter class")
    }

    //inner class
    class Increment {
        init {
            println("Inner class")
        }
        fun incrementValue(){
            println("increment value")
        }
    }

    fun createInner() {
        val inc = Increment()
    }
}

fun main() {
    //using outter class method
    val counter = Counter()
    counter.createInner()
    //using outter class
    val inner = Counter.Increment()
    inner.incrementValue()
}
.....................................................................................
			 Object expressions - Static Variables
.....................................................................................
package com.wipro.kotlin.oo.innerclasses

class Employee {
    var person = object {
        var id = 1
        var firstName = "Subramnaian"
    }

}

//static variables
object Message {
    var Warning = "Warning"
}


fun main() {
    var Person = object {
        var id = 1
        var firstName = "Subramnaian"
    }
    println(Person.id)
    println(Person.firstName)
    var emp = Employee()
    println(Message.Warning)
}
....................................................................................
			Companion Objects
...................................................................................

if you want to create single ton of  a class
companion objects are used to create instance of class using factory methods.

companion vs object
package com.wipro.kotlin.oo.innerclasses

class Greetings {
    fun sayHello() {
        println("Factory")
    }

    object Factory {
        fun createInstance(): Greetings = Greetings()
    }
}

class Hello {
    companion object Factory {
        fun createInstance(): Greetings = Greetings()
    }
    fun sayHello() {
        println("Factory")
    }
}

//
fun main() {
    Greetings.Factory.createInstance().sayHello()
    //companion objects are used to access its properties with outer class
    Hello.createInstance().sayHello()
}
....................................................................................
			Scope functions
....................................................................................
Scope functions are built in kotlin standard lib functions like toString,hashcode,equals

Scope functions primary purpose is to execute a block code(lambd) within the context of an object.

"Scope" means when you call scope functions on an object with a lambda expressions provided, it forms temporary scope, you can access the properties without its name.

There are five scope functions

1.let 
2.run 
3.with
4.apply
5.also

Pre Scope function:
package com.wipro.kotlin.oo.scopefunctions

data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    var user = User(name = "Subramanian", location = "Coimbatore", points = 10)
    //access properties
    println("Name ${user.name}")
    println("Location ${user.location}")
    println("Points ${user.points}")

    //update location and points
    user.updateLocation("Chennai")
    user.incrementPoints()
    println("Location ${user.location}")
    println("Points ${user.points}")
}

Here we access the object properties using reference variable.
The same property we can access using "scope functions".
...................................................................................

How to use scope functions?
....................................................................................
Function Name	   Object Reference        Return Value  isExtension Function
....................................................................................
let                it                      Lambda         Yes
run                this                    Lambda         yes
with               this                    Lambda         no
apply              this                    Object         yes
also               it                      Object         yes
.....................................................................................
Function name says that name of the scope function.
Object reference says that how object properties are accessed inside scope lambda(it,this)
Return value says that what is return value of scope functions values could be object itself(this) or lambda expression
isExtension says that whether that scope is member function or extension function.

These scope functions are available as part of "Any" class. so that these functions are available in every object.


let :
package com.wipro.kotlin.oo.scopefunctions.letfun

data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    User(name = "Subramanian", location = "Coimbatore", points = 10).let {
        println("Name ${it.name}")
        println("Location ${it.location}")
        println("Points ${it.points}")
        //return object reference
        it
    }.let {
        it.updateLocation("new Delhi")
        it
    }.let {
        it.incrementPoints()
        it
    }.let {
        println("Location ${it.location}")
        println("Points ${it.points}")
    }

}

...
run:
package com.wipro.kotlin.oo.scopefunctions.runfun

data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    User(name = "Subramanian", location = "Coimbatore", points = 10).run {
//        println("Name ${this.name}")
//        println("Location ${this.location}")
//        println("Points ${this.points}")
                //in side run this keyword is implicit
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
        //return
        this
    } .run {
        updateLocation("New Delhi")
        this
    } .run {
        incrementPoints()
        this
    } .run {
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
    }
}
...
with:
package com.wipro.kotlin.oo.scopefunctions.withfun


data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    //note: with can't be chained
    with(User(name = "Subramanian", location = "Coimbatore", points = 10)) {
//        println("Name ${this.name}")
//        println("Location ${this.location}")
//        println("Points ${this.points}")
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
        this
    }.run {
        updateLocation("Chennai")
        this
    }.run {
        incrementPoints()
        this
    }.run {
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
    }

}

apply:
 return value is implicit-this

package com.wipro.kotlin.oo.scopefunctions.applyfun

data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    User(name = "Subramanian", location = "Coimbatore", points = 10).apply {
        //        println("Name ${this.name}")
//        println("Location ${this.location}")
//        println("Points ${this.points}")
        //in side run this keyword is implicit
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
        //dont need to return this keyword
    }.apply {
        updateLocation("Chennai")
    }.apply {
        incrementPoints()
    }.apply {
        println("Name ${name}")
        println("Location ${location}")
        println("Points ${points}")
    }

}


also:
 Same as apply but it
 it is implicit.

package com.wipro.kotlin.oo.scopefunctions.alsofun


data class User(var name: String = "", var location: String = "", var points: Int = 0) {
    //biz logic
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }
}

fun main() {
    User(name = "Subramanian", location = "Coimbatore", points = 10).also {
        println("Name ${it.name}")
        println("Location ${it.location}")
        println("Points ${it.points}")
        //dont need to return it keyword
    }.also {
        it.updateLocation("Chennai")
    }.also {
        it.incrementPoints()
    }.also {
        println("Name ${it.name}")
        println("Location ${it.location}")
        println("Points ${it.points}")
    }

    //mix:
    with("subramanian".run {
        uppercase()
        trim()
        this
    }) {
        println(length)
    }
}
.....................................................................................
			Operator Overloading
.....................................................................................

Operator overlading means we can use existing operators for different purposes let say
+ operator is used for arthmetic operations
19+ 10  - Numerical computation

+ used to concat two strings or string with any value

in order to implement operator over loading kotlin offers a function called "operator" function.

operator function can be member function or extension function for an object

package com.wipro.kotlin.oo.operatoroverloading

class Person {
    var skills: String? = null
    fun show() = skills
}

//operator function
operator infix fun Person.plus(person: Person): Person {
    var newPerson = Person()
    newPerson.skills = this.skills + person.skills
    return newPerson
}

fun main() {
    var person1 = Person()
    person1.skills = "Kotlin"

    var person2 = Person()
    person2.skills = "Spring boot"
    //coimbine or add
    person1.plus(person2).apply {
        println(show())
    }
    //built in operators have been overloaded.
    var a = 10
    print(a.plus(23))

}
.....................................................................................
			  Generics
.....................................................................................
classes and functions in kotlin can have type parameters

class Box<T>(t:T) {
  var value  = t
}

package com.wipro.kotlin.oo.generics

class Box<T>(t: T) {
    var value = t
}

fun main() {
    var box1: Box<Int> = Box(10)
   // var box2: Box<Int> = Box("test")
}
................
Generic functions:
..................
package com.wipro.kotlin.oo.generics

interface Repository {
    //generic function
    fun <T> getById(id: T): T
    fun <E> getAll(): List<E>
}

class RepositoryImpl : Repository {
    override fun <T> getById(id: T): T {
        return  id ;
    }

    override fun <E> getAll(): List<E> {
        TODO("Not yet implemented")
    }

}

fun main() {
    var repository = RepositoryImpl()
    repository.getById<String>("test")
}
.....................................................................................
				Collections
.....................................................................................

1.Arrays
2.List
3.Set
4.Map



Arrays:
package com.wipro.kotlin.collections

fun main() {
    var myIntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    println(myIntArray.get(0))
    myIntArray.forEach { println(it) }
    val courses = arrayOf("Kotlin", "Java", "Scala", "Groovy")
    courses.iterator().forEach { println(it) }
}

List:
   Ordered collection
    with elements by index
    with elements by hashcode
    with by insertion order.

Set  
  collection with unique elements - no duplicates
  order is determined by natual order of the element
  
Map
  set of key value pair
  keys are unique,each of them maps exactly one value.

collections types:
1.immutable collection -  readonly collection
3.mutable collection - with readonly collection with write operations.

mutableList:
package com.wipro.kotlin.collections

fun main() {
    var list = mutableListOf<Int>(1, 2, 4)
    list.forEach(::println)
    list.add(12)
    list.add(233)
    list.forEach(::println)
    //scope functions
    mutableListOf<Int>(1, 2, 4).apply {
        add(13)
        add(333)
        add(20)
    }.apply {
        sortByDescending { it }
    }.let {
        println("After sorting")
        it.forEach(::println)
    }

}

Set:
....
package com.wipro.kotlin.collections

fun main() {
    mutableSetOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).apply {
        add(12)
        add(1)
        add(3)
        add(4)
    }.let {
        it.forEach(::println)
    }
}

Map:
....
package com.wipro.kotlin.collections

fun main() {
    mutableMapOf<String, Int>("value1" to 100, "value 2" to 200).apply {
        values.forEach(::println)
        keys.forEach(::println)
    }
}
.............

Collection Processing:
package com.wipro.kotlin.collections

fun transformation() {
    //readable
    listOf<Int>(1, 2, 3, 4, 5).let {
        it.forEach(::println)
        it
    }.let {
        //double it
        it.map { i -> i * 2 }.forEach(::println)
    }
}

fun main() {
    transformation()
}
.....................................................................................
			Asynchronous Programming
.....................................................................................
For decades, the programmers we confronted with a problem to sovle - How to prevent our applications from blocking.
Whether we are developing desktop applications,mobile apps,or even server-side app, we want to avoid having the user wait or what worse cause bottlenecs that would prevent an application from scalling.

Java language itself provides non blocking io apis for performing non blocking operations.
for eg if you read or write into socket or file system, it can be nonblocking ...

Non blocking means the thread is not blocked for an io operation or not using multiple threads for performing network operations.

java language provides java.nio package for performing non blocking operations.

There are frameworks today available to build non blocking application.

1.netty framework
2.Apache MINA framework.


On top of netty many frameworks

1.vertx
2.Quarkus
3.Project Reactor-Spring

Programming styles for building non blockings

1.Threading
2.callbacks
3.Futures and Promises
4.Reactive Extension - 
5.Co Routines


What is coroutines?
 Coroutines are computer program components that allow execution to be suspended and resumed.generalizing subroutines for cooperative multitasking

cooperative multitasking:

   Cooperative multitasking, also known as non-preemptive multitasking, is a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process.

 Instead, in order to run multiple applications concurrently, processes voluntarily yield control periodically or when idle or logically blocked.

coroutine is a function , when a co routine talks to another co routine function , first function is suspended, second function can be resumed...


AFunction (){
  AnotherFunction()-----------> Afunction is suspended AnotherFunctions gets executed

}
functions are cooperative each other by suspending and resuming each other....

...................................................................................

Coroutines getting started:

Kotlin core language does not provide coroutine feature.

implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")


HelloWorld coroutine:
package com.wipro.kotlin.coroutines

import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch

//simple suspend function
suspend fun sayHello() {
    println("Hello is running in ${Thread.currentThread().name}")
}


fun main() {
    println("main starts")
    val scope = GlobalScope
    scope.launch {
        sayHello()
    }

    //pause the main thread for some time
    Thread.sleep(5000)
}

Short cuts of Coroutine scopes
package com.wipro.kotlin.coroutines

import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

//simple suspend function
suspend fun sayHello() {
    println("Hello is running in ${Thread.currentThread().name}")
}


//fun main() {
//    println("main starts")
//    val scope = GlobalScope
//    scope.launch {
//        sayHello()
//    }
//
//    //pause the main thread for some time
//    Thread.sleep(5000)
//}

fun main() {
    GlobalScope.launch {
        sayHello()
    }
    Thread.sleep(5000)

}
//
//fun main() = runBlocking {
//    launch {
//        sayHello()
//    }
//    println("main")
//
//}

Here we have found "lanuch","runBlocking"
  Coroutine builder.

Coroutine builder is a function which creates a new Coroutines and binds in a scope.

launch is builder, lauches new corutine concurrently with the rest of the code, which works continues to work independently.

runBlocking is also coroutine builder that brideges the non-coroutine world of regular main function and the code with coroutines inside of runBlocking

Launching coroutines are eq to threads

in thread
 thread.start()-----execution begins
 GlobalScope.lanuch ---execution begins

GlobalScope:

public object GlobalScope : CoroutineScope 

 A Global coroutinescope not bound to any job.
 Global scope is used to lanuch any top level co-routines which are operating on the whole application lifetime and are not cancelled pre maturally.

CoroutineScope:
   This is top level
.....................................................................................

package com.wipro.kotlin.coroutines

import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

suspend fun timer() {
    //Thread.sleep(2000)
    delay(2000)
    println("Hello")
}


fun main() {

    GlobalScope.launch {
        timer();
    }
    println("world")
    Thread.sleep(5000)
}
...................................................................................
				Coroutine Builders
....................................................................................

It is a factory funtion to create a coroutine.
Co routine builders can be called from normal functions like main, because they cant suspend themselves.

1.lanuch
 start new coroutine in the background and keep working....
 lanuch returns Job Object
2.runblocking
   Blocks the current thread and waits for the other coroutines to finish its exection

3.async
   start new coroutine , performs async operations and return a "Defered" Object 
   Which is eq to Promise object in javascript.
   We can call "await" on the Defered value in order to wait and get the result.
.................................................................................
			Lanuch and Job
....................................................................................
package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {
    var job: Job = launch {
        delay(1000L)
        println("world!")
    }
    println("Hello")
    job.join();
    println("done")

}
.....................................................................................
		  Compare Threads and coroutines
.....................................................................................



package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlin.concurrent.thread

//Thread code
fun main() {
    //we should wrap this code with context of coroutine
//    repeat(1000000) {
//        thread(name="mythread") {
//            Thread.sleep(500)
//            print("*\n")
//        }
//    }

    //cpu intensive task must be executed with in coroutine
    runBlocking {
        repeat(100000) {
            var job = GlobalScope.launch {
                delay(100)
                println("*")
            }
            job.join()
        }
    }
}
...................................................................................
			 Multiple Coroutine jobs
...................................................................................

package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() {
    runBlocking {
        var job1 = GlobalScope.launch {
            println("Job1 Thread : ${Thread.currentThread().name}")
        }
        job1.join()
        var job2 = GlobalScope.launch {
            println("Job2 Thread : ${Thread.currentThread().name}")

        }
        job2.join()
        var job3 = GlobalScope.launch {
            println("Job3 Thread : ${Thread.currentThread().name}")
        }
        job3.join()
    }
}
.................................................................................
			Cancel Coroutine and How to enable Timeouts
////////////////////////////////////////////////////////////////////////////////////


In long running application you might need fine-grained control on your backroutines

for eg:
 User might have closed the page, that launched a coroutine still it is running and also its result is no longer needed and it has to be cancelled.


How to cancel coroutine?
package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.*


fun main() {

    runBlocking {
        var job1 = GlobalScope.launch {
            repeat(1000) {
                println("job : I am sleeping $it")
                delay(500L)
            }
        }
        delay(1300L)
        println("Main : i m tired of waiting!")
//        job1.cancel()
//        job1.join()
        job1.cancelAndJoin()
        println("main: now i can be happy, good bye")
    }
}

....................................................................................
			  Timeouts
/////////////////////////////////////////////////////////////////////////////////////

if you dont want to run the coroutine beyond the time you expect.

lets say i want to run coroutine within 200ms , beyond it, cancel the coroutine.



import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout

fun main() {
    runBlocking {
        withTimeout(1500L) {
            repeat(1000){
                println("job : I am sleeping $it")
                delay(500)
            }
        }
    }
}
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1500 ms
	at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:191)
	at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:159)
	at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:501)
	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:280)
	at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:109)
	at java.base/java.lang.Thread.run(Thread.java:833)

what if i dont exception

package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import kotlinx.coroutines.withTimeoutOrNull

fun main() {
    runBlocking {
       var result = withTimeoutOrNull(1500L) {
            repeat(1000){
                println("job : I am sleeping $it")
                delay(500)
            }
        }
        println("$result")
    }
}
.....................................................................................
			   async builder
.....................................................................................

creates a coroutine and returns its future result as an implementation of "Defered"

async and launch is similar where async returns value to caller, lanuch does not return values.

fun async():Defered<T>

Defered value is  a non blocking cancellable future-It is job with Result.

Getting result:
  await
     Pause the current exection until the result is available without blocking the current thread and resumes the defered computation is completed

package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.Deferred
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking

fun main() {
    runBlocking {
        val res: Deferred<String> = async {
            println("Hello async")
            delay(5000L)
            //Return value: value type can be anything
            "Hello,How are you, i am from Future"
        }
        res.join()
        println("Value ${res.await()}")
    }
}
.....................................................................................
			Sequential Composition and concurrent compostion 
....................................................................................

Sequential compostion means calling suspend functions one by one in nonblocking, get result 

Concurrent compostion means calling suspend functions parallelly , get result finally.

package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlin.time.ExperimentalTime
import kotlin.time.measureTime


suspend fun getvalueOne(): Int {
    delay(1000L)
    return 10
}

suspend fun getvalueTwo(): Int {
    delay(1000L)
    return 122
}

@OptIn(ExperimentalTime::class)
fun main() {
    runBlocking {
        var time = measureTime {
            var task1 = getvalueOne()
            var task2 = getvalueTwo()
            println("The Result is ${task1 + task2}")
        }
        println("Time taken for all tasks is $time")
    }
}

The Result is 132
Time taken for all tasks is 2.012886s
...................................................................................
			 async compostion
...................................................................................
package com.wipro.kotlin.coroutines.builders

import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlin.time.ExperimentalTime
import kotlin.time.measureTime


suspend fun getValOne(): Int {
    delay(1000L)
    return 10
}

suspend fun getValTwo(): Int {
    delay(1000L)
    return 122
}

@OptIn(ExperimentalTime::class)
fun main() {
    runBlocking {
        var time = measureTime {
            var task1 = async { getvalueOne() }
            var task2 = async { getvalueTwo() }
            println("The Result is ${task1.await() + task2.await()}")
        }
        println("Time taken for all tasks is $time")
    }
}
The Result is 132
Time taken for all tasks is 1.024629400s
..................................................................................	
			 How to start coroutine Lazy
...................................................................................
Any coroutine is started execution immediately as soon as it is lanuched

if you want to start coroutine based on some activity like clicking button, chaning tabs.
	package com.wipro.kotlin.coroutines.builders.lazy

import kotlinx.coroutines.*
import kotlin.time.ExperimentalTime
import kotlin.time.measureTime


suspend fun getValOne(): Int {
    delay(1000L)
    return 10
}

suspend fun getValTwo(): Int {
    delay(1000L)
    return 122
}

@OptIn(ExperimentalTime::class)
fun main() {
    runBlocking {
        var time = measureTime {
            var task1 = async(start = CoroutineStart.LAZY) { getValOne() }
            var task2 = async(start = CoroutineStart.LAZY) { getValTwo() }
            launch {
                delay(5000L)
                task1.start()
                task2.start()
                println("The Result is ${task1.await() + task2.await()}")
            }
        }
        println("Time taken for all tasks is $time")
    }
}
.....................................................................................
			Dispatchers and threads
.................................................................................
The coroutine context includes coroutine dispatcher that determines what thread or threads  the correponding coruoutine uses for its execution.

How to use Dispatchers ?
 package com.wipro.kotlin.coroutines.dispatchers

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() {
    runBlocking {
        launch {
            println("main run Blocking : i am working in thread ${Thread.currentThread().name}")
        }
        launch(Dispatchers.Default) {
            println("Default  : i am working in thread ${Thread.currentThread().name}")
        }
        launch(Dispatchers.IO) {
            //networking code, database logic
            println("IO  : i am working in thread ${Thread.currentThread().name}")

        }

    }
}
.....................................................................................
			Sync and async multiple values
...................................................................................
Mutliple values can be returned in kotlin using collections.
package com.wipro.kotlin.coroutines.sequences

fun simple(): List<Int> = listOf(1, 2, 3, 4)

fun main() {
    simple().forEach { value -> println(value) }
}

Async way of returning list of values

sequence builder:
................
package com.wipro.kotlin.coroutines.sequences

import kotlinx.coroutines.delay

fun simple(): List<Int> = listOf(1, 2, 3, 4)

//
fun asyncList(): Sequence<Int> = sequence {
    for (i in listOf<Int>(1, 2, 3, 4)) {
        Thread.sleep(500)
        //return sequence of values
        yield(i)
    }
}

fun main() {
    //simple().forEach { value -> println(value) }
    asyncList().forEach { value -> println(value) }
}
....................................................................................
			Streaming using Flows and Channles
.....................................................................................

Channels are way to transmit "Defered Single" between coroutines.
Flows are way to transmit "Defered sequence of(more) values" between coroutines.

There are two methods in channels ; suspend send method and suspend receive method

package com.wipro.kotlin.coroutines.channels

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() {
    GlobalScope.launch {
        //create a channel
        val channel = Channel<Int>()
        //send data async in coroutine
        launch(Dispatchers.Default) {
            //publish data inside one coroutine
            println("Publishing in ${Thread.currentThread().name}")
            for (i in 10 downTo 0) channel.send(i)
        }

        //Receiving
        launch(Dispatchers.IO) {
            println("Receiving from ${Thread.currentThread().name}")
            for (j in channel) println("downloading $j")
        }
    }
    Thread.sleep(10000L)
}
.....................................................................................
	 Streaming-Multi Values Exchaning between coroutines
	   		(Emit and Collect)
....................................................................................

What is Flow?
  A supend function can return a single value but what if i want to return multiple asynchronously computed values(sequence of values)?
That is where the Flow comes into picture.

Mutli values can be represented by using collections...
package com.wipro.kotlin.coroutines.flows

import kotlinx.coroutines.runBlocking

//Blocking sequence
//fun getValues(): Sequence<Int> = sequence {
//    for (i in 1..10) {
//        Thread.sleep(100)
//        yield(i)
//    }
//}

suspend fun getValues(): List<Int> = listOf(1, 2, 3)
fun main() {
    runBlocking {
        getValues().forEach(::println)
    }
}

Here we have achived async, but data is returned in one short.

what if i want stream of values - Flow:

Flow == sequence with async operation.
package com.wipro.kotlin.coroutines.flows

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun getAsynValue(): Flow<Int> = flow {
    for (i in 1..10) {
        delay(100)
        println(Thread.currentThread().name)
        emit(i)
    }
}

fun main() {
    runBlocking(Dispatchers.IO) {
        launch {
            //collect values
            getAsynValue().collect { value -> println("Got $value") }
        }
    }
}
...................................................................................
			How to cancel flow : with timeout or withTimeoutNull.

package com.wipro.kotlin.coroutines.flows

import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeoutOrNull

fun doSomething(): Flow<Int> = flow {
    for (i in 1..10) {
        delay(100)
        println(Thread.currentThread().name)
        emit(i)
    }
}

fun main() {
    runBlocking {
        withTimeoutOrNull(200) {
            doSomething().collect { value -> println("Got $value") }

        }
    }
}
...................................................................................
			  Flow Builders
....................................................................................

The flow {} builder from the previous concept is most basic one, There are other builders too.

1.flowOf -  emits a fixed set of values
2.asFlow -- collections and sequences can be converted into flow

package com.wipro.kotlin.coroutines.flows

import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.runBlocking

fun main() {
    runBlocking {
        listOf<Int>(1, 2, 3, 4, 5).asFlow().collect {
            println("$it")
        }
    }

}
.....................................................................................
			  Flow Operators
.....................................................................................

Flows can be transformed using operators, in the same way you would transform collections and sequnces...

map

package com.wipro.kotlin.coroutines.flows

import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking

fun main() {
    runBlocking {
        listOf<Int>(1, 2, 3, 4, 5).asFlow().map { it * 2 }.collect {
            println("$it")
        }
    }
}
....................................................................................
		  Spring Boot Integration with kotlin

1.create project with kotlin language support.
2.start writing controller and functions

package com.example.demo

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class DemoApplication

fun main(args: Array<String>) {
	runApplication<DemoApplication>(*args)
}


package com.example.demo

import com.example.demo.entity.User
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("users")
class UserController {

    @GetMapping
    fun findAll(): List<User> {
        return listOf(User(1, firstName = "Subramanian", lastName = "Murugan"))
    }
}
package com.example.demo.entity

//@Entity
data class User(val id: Int, val firstName: String, val lastName: String)
/////////////////////////////////////////////////////////////////////////////////////
			Spring boot with Coroutine Integration
.....................................................................................

Depedencies:

dependencies {
	implementation("org.springframework.boot:spring-boot-starter-webflux")
	implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
	implementation("io.projectreactor.kotlin:reactor-kotlin-extensions")
	implementation("org.jetbrains.kotlin:kotlin-reflect")
	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
	testImplementation("org.springframework.boot:spring-boot-starter-test")
	testImplementation("io.projectreactor:reactor-test")
}
	
package com.example.mycoroutine

import kotlinx.coroutines.*
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class CoRoutinesRestController {

    @GetMapping("/name")
    fun sayMyname(): String {
        println("sayMyname: ${Thread.currentThread().name}")
        return "My Name is Subramanian"
    }

    @GetMapping("/hello")
    suspend fun getValue(): String {
        println("Hello: ${Thread.currentThread().name}")
        delay(10000L)
        return "Hello"
    }

    @GetMapping("/city")
    suspend fun sayMyCity(): String {
        val res = GlobalScope.async(Dispatchers.IO) {
            delay(500)
            println("sayMyCity: ${Thread.currentThread().name}")
            "Coimbatore"
        }
        return res.await()

    }
}
.....................................................................................
			Reactive Programming - Project Reactor
.....................................................................................
What is reactive programming?

In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change.

->declarative programming
->data streams
->propagation of change


What is Reactive?

  Oxford dictionary defines reactive  as "showing a response to a stimulus"

Response :  The result
Stimuls : trigger/actions ---Events

Get Response because of some events --- event driven programming model.

Event dirven programming is extension of  object oriented programming.

 Observer Pattern is one of the behavioral design pattern. Observer design pattern is useful when you are interested in the state of an object and want to get notified whenever there is any change.

 In observer pattern, the object that watch on the state of another object are called Observer and the object that is being watched is called Subject.


Iterator Design pattern:
	Iterator design pattern in one of the behavioral pattern. Iterator pattern is used to provide a standard way to traverse through a group of Objects.

Iterator Pattern : Pull model

caller 

class ProductConsumer{
  private ProductProvider provider;

  public void getProduct(){
	provider.getProducts().forEach(...)
  }

}

//callee

class ProductProvider { 

  public List<Product> getProducts(){ 

	return List.of(new Product(),new Product(),new Product());
  }

}
....................................................................................

Reactive Programming =  Observer Design pattern + push iterator pattern + declarative programming.

How objects communicate

      
  By passing messages via method calls with intermediate object (Event).


Publisher sends/publishes data with events via broker called notfication interface to subcribers




				Publisher/Owner/Producer
					|
				     data + event(Event)
					|
			       Event Notification Interface
					|
	      -----------------------------------------------------------------			
	     |                   |          |           |
          Listeners            Subscriber  Subscriber Subscriber


Subscribers are objects who are listening for events, once event is given, who process event and consume take.

Legacy observer design pattern has only 1 thing

  1.they will be able to send only data

Have not addresssed the following
  1.what if error is produced
  2.what if the producer has stopped producing values. 

Reactive programming address the above issues.

Producer can send data,error, complete - events/signals

				Publisher/Owner/Producer <---------Data Source(Device)
					|
				 data / error  & complete
					|
			       Event Notification Interface
					|
			------------------------------------- channels
			|               |                  |
                     data              error              complete

			|		|		   |
			------------------------------------
					  |
				      Subscriber
			

Iterator Design Pattern design:

				   DataSource-List/Collection -Object
				    (1,2,3,4,5,6,7,8,9,10)
					  |
				Iterator - PULL Alogorthim- get/read/request(1)
					   |
				 Subscribers -add into HTTP OUTPUTSTREAM-1,2

PULL Based iterator , is default iterator already implemented in many languages.

Drawbacks of pull based iterator :

1.both object should sync each other.
2.only data will be pulled via iterator.next/get/read/request call
3.Errors are handled via try...catch.
4.No complete signal is given.
5.all data must be loaded in advance- memory waste
6.live data may not be processed on fly.


PUSH BASED Iterator :  Reactive Implementation.



	          Publisher/Owner/Producer <---------Data Source(Device)
					|
				  push data into memory over time.
					|
				  -----------------------------
                                      1---2---3--4--error--5--|-->
				  ------------------------------
                        		|    
				   emit event data,data -complete           	
			
				 data / error  & complete
					|
			       Event Notification Interface
					|
			------------------------------------- channels
			|               |                  |
                     data              error              complete

			|		|		   |
			------------------------------------
					  |
				      Subscriber


 When error or complete signal is given, channel will be closed.

Reactive Programs are functional style based.

 -Pure functions
 -Immutablity
 -Higher order functions: function composition.

Reactive  = {observable + iterator(push) + functional style} 

Reactive is just spec, what about implementation? who has given this implementation.

Reactive spec initally implemented not as open source project , by netflex ->
  RxJava 1.0 - open source.

Once Rxjava other extensions came into market,developer started building reactive application.

one point of time, people had confusion.

Whether my system is Reactive?

Many companies like ms,google,netflex,amzon....joined together who published one spec
https://www.reactivemanifesto.org/


Where is reactive Programming ? Use case of Reactive Programming?


   ********Data  Streaming and Processing in blocking and nonblocking *******

Data Processing  y comapare with Batch processing.....

Pipe lines : streaming of data.

Stream :

     Sequence of data / flow of data which is supplied and consumed .

Stream Types:

1.Source Stream
2.Intermediate Stream 

 ->Up Stream
 ->Down Stream


Core Concepts in Reactive Programming:
......................................

1.Publisher
   Publisher is Object
2.Subscriber
   Subscriber is also Object
3.Stream
  logical representation of data movement

Java and Reactive Programming implementation:
 
Reactive programming spec 

1.Rxjava 1.x
2.Rxjava 2.x,Rx 3, Rx 4
3.Project Reactor
4.Java 9 onwards
5.Mutiny

....................................................................................
			 Reactive Streams
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

https://www.reactive-streams.org/

 It is spec created for java applications for processing events.

.....................................................................................
  			Birth of Project Reactor


Project Reactor born with 
- simple , meaning full Publisher apis
- BackPressure Ready
- Non Blocking Ready-Netty Engine integration.
- fully reactive stream implementation
.....................................................................................

Project Reactor implementation:

Project Setup with Java:
........................

Create maven project.

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>reactiveapps</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
            <version>3.4.16</version>
        </dependency>
    </dependencies>

</project>
.....................................................................................
				Project Reactor core concepts


1.Publisher 
2.Subscriber
3.Subscription
4.Operators

1.Publisher is object who publish events.

Project Reactor Types:(Publisher Types)

1.Mono 
  Publisher can publish 0 to 1 Result
2.Flux 
  Publisher can publish 0 to N items


Publisher is emitter who emits data

Subscriber is receiving data.

Subscription is "session" between Producer and Subscriber

Processor = Publisher + Subscribers  : acting as publishers and subscribers.

Operators are api to create,transform,filter,merge,join stream of data.
....................................................................................
		Project reactor is based on "Reactive Stream Spec"
.....................................................................................

reactive Streams api;

package org.reactivestreams;

public interface Publisher<T> {
    void subscribe(Subscriber<? super T> var1);
}

reactor extension

package reactor.core;

import org.reactivestreams.Publisher;

public interface CorePublisher<T> extends Publisher<T> {
    void subscribe(CoreSubscriber<? super T> var1);
}
implementation class

public abstract class Mono<T> implements CorePublisher<T> {
....
}
public abstract class Flux<T> implements CorePublisher<T> {
....
}


Subscribers:

package org.reactivestreams;

public interface Subscriber<T> {
    void onSubscribe(Subscription var1);

    void onNext(T var1);

    void onError(Throwable var1);

    void onComplete();
}

package reactor.core;

import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.util.context.Context;

public interface CoreSubscriber<T> extends Subscriber<T> {
    default Context currentContext() {
        return Context.empty();
    }

    void onSubscribe(Subscription var1);
}


Subscription:
.............
  Session between Producer and Subscriber


public interface Subscription {
    void request(long var1); // how many elements subscriber can handle: kind of backPressure

    void cancel(); // to close session between Producer and subscriber.
}
.....................................................................................
				Flux
.....................................................................................

Create Flux
Emit events
Subscribe and listen for data

Create Flux:
 Flux can be created using various ways- creation operators...

Every creation operators are static methods.
package com.wipro.reactor.creations;

import reactor.core.publisher.Flux;

public class FluxPublisherCreate {
    public static void main(String[] args) {
        //create Flux
        Flux<Integer> producer = Flux.create(fluxSink -> {
            //emit event : push item into stream(pipelien),later we attach listener to listen for data
            fluxSink.next(1); //emit event and send data
            fluxSink.next(2);
            fluxSink.next(3);
            fluxSink.next(4);
            fluxSink.complete(); //no more data...
        });
        //subscriber or caller
        //producer.log().subscribe();
        producer.subscribe(data -> System.out.println(data));
    }
}

Just;
package com.wipro.reactor.creations;

import reactor.core.publisher.Flux;

public class FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4, 5, 6).subscribe(integer -> {
            System.out.println(integer);
        });
        Flux.just("subramanian","murugan","karthik").subscribe(name -> {
            System.out.println(name);
        });
    }
}

List :
package com.wipro.reactor.creations;

import reactor.core.publisher.Flux;

import java.util.List;

public class ListImpl {
    public static void main(String[] args) {
        List<Integer> integerList = List.of(1, 2, 3, 4, 5);
        Flux.fromIterable(integerList).subscribe(item -> {
            System.out.println(item);
        });

        Integer[] data = {1, 2, 3, 4, 5};
        Flux<Integer> producerArray = Flux.fromArray(data);
        producerArray.subscribe(integer -> {
            System.out.println(integer);
        });

        //sequence of numbers from start to end : range
        Flux<Integer> rangeProducer = Flux.range(1, 100);
        rangeProducer.subscribe(r -> {
            System.out.println(r);
        });
    }
}

Subscribe methods :

Overloaded version of subscribe:

subscribe(); 

subscribe(Consumer<? super T> consumer); 

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); 

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); 



Subscribe and trigger the sequence.
Do something with each produced value.
Deal with values but also react to an error.
Deal with values and errors but also run some code when the sequence successfully completes.
Deal with values and errors and successful completion but also do something with the Subscription produced by this subscribe call.

sink:
 go down below the surface of something, especially of a liquid; become submerged.


Subscription Eg:
When stream will closed?
 - once exception is thrown
 - once complete is called.



Subscriber life cycle methods:
..............................
org.reactivestreams.Subscriber

1.onSubscribe
    is called when subscriber subcribes to producer. : init

2.OnNext
    is called for each Chunk of data requested.
3.OnError
    is called for if any error signal is propagated

4.onComplete
   is called for if any complete signal is triggered.

...................................................................................
				Back Pressure
..................................................................................

When upstream is fast than down stream - back pressure happens.

What will happen when back pressure happens?
  Data loss.

Reactive Streams gives power to handle back pressure.

As we have seen , reactive systems are  "push" based, that means publisher keep on publishing events without worrying about consumers.

Reactive streams introduced new concept called "pull" programming "reactive pull".

Reactive pull ===> push + pull

Consumer can pull data when ever he wants, consumer now can handle pressure by sending request to "upstreams" that give me this much data only....


Subscription:
 
 Interface is used to control data flow between source(up) stream to subscriber(down stream)

 request(unbounded) ---Subscriber has no concern regarding, how many elements he is interested.

 request(long N) - request(3) -- request 3 elements only.

producer.log().subscribe(new Subscriber<Integer>() {
            @Override
            public void onSubscribe(Subscription s) {
                System.out.println("Subscription is done");
                //ask the upstream how many elements you want
                //s.request(3); //requests only 3 elements
                //request all elements
                s.request(Long.MAX_VALUE); // request(unbound)
            }

            @Override
            public void onNext(Integer value) {
                System.out.println("Data " + value);

            }

            @Override
            public void onError(Throwable t) {
                System.out.println("Error  " + t.getMessage());

            }

            @Override
            public void onComplete() {
                System.out.println("Completed ");

            }
        });


Lambda with Subscription:
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,Consumer<?super Subscription> subscriptionConsumer); 

      //lambda with subscription
        producer.subscribe(data -> {
            System.out.println(data);
        }, err -> {
            System.out.println(err);
        }, () -> System.out.println("Stream Completed"),subscription -> {
            subscription.request(2);
        });

package com.wipro.reactor.creations;

import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.core.publisher.Flux;

public class BackPressureHandling {
    public static void main(String[] args) {
        Flux.range(1, 1000).subscribe(
                new Subscriber<Integer>() {
                    @Override
                    public void onSubscribe(Subscription subscription) {
                        //backpressure code
                        subscription.request(3);
                    }

                    @Override
                    public void onNext(Integer integer) {
                        System.out.println(integer);
                    }

                    @Override
                    public void onError(Throwable throwable) {
                        System.out.println(throwable.getMessage());
                    }

                    @Override
                    public void onComplete() {
                        System.out.println("Completed");
                    }
                }
        );
    }
}
.....................................................................................
			how to handle data,error,complete without using subscribe
....................................................................................
We have utility methods.

package com.wipro.reactor.creations;

import reactor.core.publisher.Flux;

public class UtiltiyMethods {
    public static void main(String[] args) {

        Flux.range(1, 10).doOnSubscribe(sub -> {
            System.out.println("doOn Subscription");
        }).doOnNext(data -> {
            System.out.println("doOnNext " + data);
        }).doOnRequest(n -> {
            System.out.println(n);
        }).doOnError(err -> {
            System.out.println("doOnError " + err);
        }).doOnComplete(() -> {
            System.out.println("doOnComplete");
        }).log().subscribe();

    }
}
.....................................................................................
			 Stream Processing -Flux
.....................................................................................
Operators:

map : transformation operator : which transforms data,returns new Producer.
package com.wipro.reactor.processing;

import reactor.core.publisher.Flux;

import java.util.function.Function;

public class Trasnformation {
    public static void main(String[] args) {
        //Flux.range(1, 10).map(i -> i * 2).log().subscribe();
        Function<Integer, Integer> multiplyByTen = (x) -> x * 10;
        Flux.range(1, 10).map(multiplyByTen).log().subscribe();
    }
}
filter:
 Predicate : Apply boolean function, if it is true, then only it will move down stream.
package com.wipro.reactor.processing;

import reactor.core.publisher.Flux;

public class Filter {
    public static void main(String[] args) {
        Flux.range(1, 10).filter(i -> i % 2 == 0).log().subscribe();
    }
}

How to create sequence of operators(coimbine operators)..

  source--->map-->filter-->subscribe

 map is called for every element
 filter is called if condition is true.
package com.wipro.reactor.processing;

import reactor.core.publisher.Flux;

import java.util.function.Function;
import java.util.function.Predicate;

public class MapFilterOperator {
    public static void main(String[] args) {
        Function<Integer, Integer> multiplyByTen = (x) -> x * 3;
        Predicate<Integer> testEven = x -> x % 2 != 0;
        Flux.range(1, 10).map(multiplyByTen).filter(testEven).log().subscribe();
    }
}
Nested Flux:

 Flex<Flex>

map- transformation operator , which transform items and retuns new stream.

flatMap is inspisired from nested arrays in javascript

  [
    [
    
    ]
  ]
how to process nested array, we have write inner loop.
   -flatting process ==> converting nested array into single array.

package com.wipro.reactor.processing;

import reactor.core.publisher.Flux;

public class Flatting {
    public static void main(String[] args) {
        Flux<String> stream1 = Flux.just("Hello", "Hi", "How are you", "What about you");
        stream1.map(item -> item).log().subscribe();

        stream1.flatMap(item -> {
            return Flux.just(item + "World");
        }).log().subscribe(System.out::println);
    }
}

Complex processing:
package com.wipro.reactor.processing;

import reactor.core.publisher.Flux;

import java.util.Arrays;
import java.util.List;

public class FlatMapCoimbined {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("the", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog");
        Flux<String> fewWords = Flux.just("Hello", "World");
        Flux<String> manyWords = Flux.fromIterable(words);
        //complex biz logic with declarative approach.
        Flux<String> manyLetters = Flux
                .fromIterable(words)
                .log()
                .flatMap(word -> Flux.just(word))
                .log()
                .distinct()
                .log()
                .sort()
                .log()
                .zipWith(Flux.range(1, Integer.MAX_VALUE),
                        (string, count) -> String.format("%2d. %s", count, string));

        manyLetters.log().subscribe(System.out::println);
    }
}
.....................................................................................
				 Mono - o ... 1 Item
..................................................................................
package com.wipro.reactor.creations;

import reactor.core.publisher.Mono;

public class MonoCreateOperator {
    public static void main(String[] args) {
        Mono<String> single = Mono.create(monoSink -> {
            monoSink.success("Hello");
        });
        single.subscribe(data -> {
            System.out.println("data " + data);
        }, err -> System.out.println("Errror " + err.getMessage()));

        //Mono Creation operators
        Mono.just("How are you?").log().subscribe();
        //no value
        Mono.empty().log().subscribe();
        
        Mono.error(new RuntimeException("something went wrong")).log().subscribe();


    }
}
..
MonoWith Delay:
...............
package com.wipro.reactor.creations;

import reactor.core.publisher.Mono;

import java.time.Duration;

public class MonoWithDelay {
    public static void main(String[] args) {
        Mono.just("Hello, I am delayed")
                .delayElement(Duration.ofSeconds(2))
                .doOnSuccess(System.out::println)
                .log()
                .block(); //block this thread until result is available.

    }
}
....................................................................................

Threading and Reactor Concurrency(declarative Concurrency):
...........................................................
In general , Stream processing happens in main thread. suppose if you want to deligate
the stream process in a separate thread.

Why separate thread of execution?
 Concurrency.

How to implement conncurrency?

1.Using plain vannila thread implementation: not recommended 
2.Using Schedulers : highly recommended.

Schedulers are similar to an ExecutorService in plain java. but Shedulers has been designed for Reactive Exection.


The Schedulers class has static methods that give access to the following execution contexts:
...............................................................................................
The current thread (Schedulers.immediate()).

A single, reusable thread (Schedulers.single()).

Note that this method reuses the same thread for all callers, until the Scheduler is disposed. If you want a per-call dedicated thread, use Schedulers.newSingle() for each call.


An elastic thread pool (Schedulers.elastic()). It creates new worker pools as needed, and reuse idle ones.
 Worker pools that stay idle for too long (default is 60s) are disposed. This is a good choice for I/O blocking work for instance. Schedulers.elastic() is a handy way to give a blocking process its own thread, so that it does not tie up other resources.

a fixed pool of workers that is tuned for parallel work (Schedulers.parallel()). It creates as many workers as you have CPU cores

  Scheduler mys = Schedulers.newSingle("test");
        Mono.just("Hello, I am delayed")
                .delayElement(Duration.ofSeconds(2),Schedulers.newElastic("xxx"))
                .doOnSuccess(System.out::println)
                .log()
                .block(Duration.ofSeconds(10)); //block this thread until result is available.


package com.wipro.reactor.schedulers;

import reactor.core.publisher.Flux;
import reactor.core.scheduler.Scheduler;
import reactor.core.scheduler.Schedulers;

public class PublishOnOperator {
    public static void main(String[] args) {
        Scheduler s = Schedulers.newParallel("parallel-scheduler", 5);
        Flux<Integer> flux = Flux.range(1, 5)
                .map(i -> {
                    System.out.println("First Map -> " + Thread.currentThread().getName() + " " + i);
                    return i * 10;
                })
                .publishOn(s) //downstream only take this thread
                .map(i -> {
                    System.out.println("Second Map -> " + Thread.currentThread().getName());
                    return i + 2;
                });
        flux.subscribe(System.out::println);
    }
}

subscribeOn
 applies to the subscription process,
 no mater where you place the subscribeOn in the chain.
 It always affects context of the source emission.
package com.wipro.reactor.schedulers;

import reactor.core.publisher.Flux;
import reactor.core.scheduler.Scheduler;
import reactor.core.scheduler.Schedulers;

public class SubscribeOnOperator {
    public static void main(String[] args) {
        Scheduler s = Schedulers.newParallel("parallel-scheduler", 5);
        Flux<Integer> flux = Flux.range(1, 5)
                .subscribeOn(s)
                .map(i -> {
                    System.out.println("First Map -> " + Thread.currentThread().getName() + " " + i);
                    return i * 10;
                })
                .publishOn(Schedulers.boundedElastic())
                .map(i -> {
                    System.out.println("Second Map -> " + Thread.currentThread().getName());
                    return i + 2;
                });
        //new Thread(() -> flux.subscribe(System.out::println)).start();
        flux.subscribe(System.out::println);
    }
}
....................................................................................
			 Error Handling
...................................................................................
Handling Errors:
..................

In reactive stream specs , errors are terminal events.
As soon as error occurs, it stop sequences and get propagated down the chain of operators
to the last step. the subscriber you defined and its onError method.

How to handle errors in more effective way:

 Reactor provides Error handling operators.

 1.Catch and return a static default value.
 2.Catch and execute an alternative path with a fallback method.
 3.Catch and dynamically compute a fallback value
 4.Catch and wrap to CustomException and ret-throw
 5.Catch and log error-specific message, and rethrow.
 6.you can clean resources using finally block.

package com.wipro.reactor.errorhandling;

public class SimpleErrorHandling {
    private static String doSomething(int i) {
        // System.out.println(i);
        if (i == 5) {
            throw new RuntimeException("something went wrong!!!");
        }
        return Integer.toString(i);
    }
    public static void main(String[] args) {
        //legacy code
        try {
            for (int i = 1; i < 10; i++) {
                String v1 = doSomething(i);
                System.out.println(v1);
            }

        } catch (Throwable a) {
            System.out.println("CAUGHT" + a);
        }
    }
}

Reactive Error Handling.
package com.wipro.reactor.errorhandling;

import reactor.core.publisher.Flux;

public class ReactiveErrorHandling {
    private static String doSomething(int i) {
        // System.out.println(i);
        if (i == 5) {
            throw new RuntimeException("something went wrong!!!");
        }
        return Integer.toString(i);
    }

    public static void main(String[] args) {
        Flux<String> f = Flux.range(1, 10)
                .map(v -> doSomething(v));

        f.subscribe(v -> System.out.println(v),
                err -> System.out.println("CAUGHT" + err.getMessage()));
    }
}

I dont want to terminate my program incase any exception:
...........................................................
Use case 2 : how to return static fallback value:
.................................................
 try {
            for (int i = 1; i < 10; i++) {
                String v1 = doSomething(i);
                System.out.println(v1);
            }

} catch (Throwable a) {
     return "RECOVERED";
}

package com.wipro.reactor.errorhandling;

import reactor.core.publisher.Flux;

public class ReactiveFallback {
    private static String doSomething(int i) {
        // System.out.println(i);
        if (i == 5) {
            throw new RuntimeException("sorry");
        }
        return Integer.toString(i);
    }

    public static void main(String[] args) {
        Flux.range(1, 10)
                .map(v -> doSomething(v))
                .onErrorReturn("RECOVERED")
//                .onErrorReturn(e -> e.getMessage().equals("boom10"), "recovered10")
                .subscribe(v -> System.out.println(v), err -> System.out.println(err));

    }
}
....................................................................................
				Fail fast and Flow Slow
....................................................................................

if any exception occurred, you can throw error, catch it /handle it immediately - fail fast

if any exception occurred , you dont want to fail immediatly , you have to try for some time.

package com.wipro.reactor.errorhandling;

import reactor.core.publisher.Flux;

public class Retry {
    private static String doSomething(int i) {
        System.out.println("Calling with " + i);
        if (i == 5) {
            throw new RuntimeException("sorry");
        }
        return Integer.toString(i);
    }

    public static void main(String[] args) {
        Flux.range(1, 10)
                .map(v -> doSomething(v))
                .retry(3)
                .onErrorReturn("RECOVERED")
                .subscribe(v -> System.out.println(v), err -> System.out.println(err));
    }
}
.....................................................................................
		Spring with Project Reactor - Spring Web Flux && R2DBC
.....................................................................................

Spring webFlux-  For building Reactive Web Apps(Non blocking web Apps)
R2DBC -The Reactive Relational Database Connectivity (R2DBC) project brings reactive         programming APIs to relational databases.
https://r2dbc.io/

Web Application on Java and Spring:
..................................

All web applications are written by using java techonlogy based on a spec called "Servlet Spec".

Servlet apis are multi threaded model, blocking api.

Request Per Thread, Thread is created for each request

if more requests, you can see more threads.

if a thread spends lot of time serving clients, which degrades performance,blocking , waiting.....

A single thread is used to perform end to end client operations

  client ---requests----pdf report-------------|----create a thread------->pdf service program------jdbc--|--db
					   write pdf into socket 		 |
                                                               |                  ---														   convert data into pdf
										 |
							       |--------	 write pdf into file server
                                                             response is ready

Servlet containers who implements servlet spec, follows the perclient request-thread model


In this arch, more and more threads, now we need to think how to improve this?
-Scalability
     -Verticle
     -Horizontal 

Spring WebFlux is spring boot module.

 spring-webflux

   provides reactive http and websocket ,server and clients.
    -REST ,html browser and web socket style interactions


Types of WebFlux:

HttpHandler:
..........

org.springframework.http.server.reactive

Interface HttpHandler

reactor.core.publisher.Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response)

Handle the given request and write to the response.



org.springframework.http.server.reactive

Interface ServerHttpRequest

Represents a reactive server-side HTTP request.


org.springframework.http.server.reactive
Interface ServerHttpResponse

Represents a reactive server-side HTTP response.


HttpHandler handler=........

ReactorHttpHandlerAdapter adpater=new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();


WebHandler:

 Provides a reactive extension for other features

 -session handling
 -filters
 -Serialization and deserilzation.


Request Interface ReactiveHttpInputMessage

reactor.core.publisher.Flux<DataBuffer>	getBody()
Return the body of the message as a Publisher.


org.springframework.core.io.buffer
Interface DataBuffer  Basic abstraction over byte buffers.


Response:Interface ReactiveHttpOutputMessage

Basic abstraction over byte buffers.
reactor.core.publisher.Mono<Void>	writeWith(org.reactivestreams.Publisher<? extends DataBuffer> body)
Use the given Publisher to write the body of the message to the underlying HTTP layer.


Codecs: 
  Encoder and Decorder are low level contractrs to encode and decode content indepentent 
of HTTP.

 HttpMessageReader and HttpMessageWriter contracts to encode and decode http message content

Codecs supported by spring

JACKSON2DECODER AND JACKSON2ENCODER


 Flux<DataBuffer>  <------> Flux<T>
  
 Mono<List<T>
 Mono<T>
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Spring Boot with Kotlin WebFlux:
................................
package com.example.reactiveweb

import kotlinx.coroutines.delay
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

@RestController
@RequestMapping("/users")
class UserController {

    @GetMapping
    fun getUsers(): Mono<List<String>> {
        //return Mono.just("")
        return listOf<String>("Subramanian", "Murugan").toMono()
    }

    @GetMapping("/coroutine")
    suspend fun getValue(): List<String> {
        delay(10000L)
        return listOf<String>("Subramanian", "Murugan");
    }
}
...

WebClient:
..........
  Reactive api for communicating with Rest services.


Steps:
1.service layer:
package com.example.reactiveweb

import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import reactor.core.publisher.Flux

@Service
class APIService {

    fun fetchComments(postId: Int): Flux<Comment> = fetch("posts/$postId/comments").bodyToFlux(Comment::class.java)

    fun fetchPosts(): Flux<Post> = fetch("/posts").bodyToFlux(Post::class.java)

    fun fetch(path: String): WebClient.ResponseSpec {
        val client = WebClient.create("http://jsonplaceholder.typicode.com/")
        return client.get().uri(path).retrieve()
    }
}

API Controller:
package com.example.reactiveweb

import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Mono
import reactor.core.scheduler.Schedulers
import reactor.kotlin.core.publisher.toMono

@RestController
@RequestMapping(path = ["/api"], produces = [MediaType.APPLICATION_JSON_UTF8_VALUE])
class APIController(private val apiService: APIService) {

    @RequestMapping(method = [RequestMethod.GET])
    fun getData(): Mono<ResponseEntity<List<Response>>> {
        return apiService.fetchPosts()
            .filter { it -> it.userId % 2 == 0 }
            .take(20)
            .parallel(4)
            .runOn(Schedulers.parallel())
            .map { post ->
                apiService.fetchComments(post.id)
                    .map { comment -> LightComment(email = comment.email, body = comment.body) }
                    .collectList()
                    .zipWith(post.toMono())
            }
            .flatMap { it -> it }
            .map { result ->
                Response(
                    postId = result.t2.id,
                    userId = result.t2.userId,
                    title = result.t2.title,
                    comments = result.t1
                )
            }
            .sequential()
            .collectList()
            .map { body -> ResponseEntity.ok().body(body) }
            .toMono()
    }
}
Models:
package com.example.reactiveweb


data class Comment(
    val postId: Int,
    val id: Int,
    val name: String,
    val email: String,
    val body: String
)

data class LightComment(
    val email: String,
    val body: String
)

data class Post(
    val userId: Int,
    val id: Int,
    val title: String,
    val body: String
)

data class Response(
    val postId: Int,
    val userId: Int,
    val title: String,
    val comments: List<LightComment>
)
MainApp:
package com.example.reactiveweb

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class ReactivewebApplication

fun main(args: Array<String>) {
	runApplication<ReactivewebApplication>(*args)
}







